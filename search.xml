<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三指令实现闰年检查</title>
      <link href="/Blog/2025/06/10/san-zhi-ling-shi-xian-run-nian-jian-cha/"/>
      <url>/Blog/2025/06/10/san-zhi-ling-shi-xian-run-nian-jian-cha/</url>
      
        <content type="html"><![CDATA[<p>笔者偶然在<a href="https://news.ycombinator.com/news">Hacker News</a>上读到一篇很有趣的文章<a href="https://hueffner.de/falk/blog/a-leap-year-check-in-three-instructions.html">A leap year check in three instructions</a>，文章仅用3条CPU指令就可以检查年份 $0 ≤ y ≤ 102499$ 是否为闰年：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_leap_year_fast</span><span class="params">(<span class="type">uint32_t</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((y * <span class="number">1073750999</span>) &amp; <span class="number">3221352463</span>) &lt;= <span class="number">126976</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后文章解释了其背后的运行逻辑，但有些地方笔者认为解释的不太详尽，于是有了这篇文章。当然，由于个人水平有限，如有不当之处，敬请谅解，并欢迎大家批评指正😊</p><h3 id="标准方法的优化"><a href="#标准方法的优化" class="headerlink" title="标准方法的优化"></a>标准方法的优化</h3><blockquote><p> There is a further trick well-known to compiler implementors on how to lower the modulo by 25. Compiling (x % 25) !&#x3D; 0 with gcc and translating back to C, we get x * 3264175145 &gt; 171798691. With multiplication at a typical latency of 3 cycles and modulo of at least 20 cycles, this is a great improvement.<br>对于将 $(x \% 25) !&#x3D; 0$ 替换为 $x * 3264175145 &gt; 17179869$，原文中提到<br>$$2^{32} ⋅ 19&#x2F;25 &#x3D; 3264175144.96 (exactly).$$<br>为便于理解，假定<br>$$2^{32} ⋅ 19&#x2F;25 &#x3D; k, k∈N+$$<br>此时 $(x \% 25) !&#x3D; 0$ 等价为 $x * k &gt; 0$，因为若x是25的倍数，那么 $x * k$ 的结果将会是一个正整数左移32位，结果上溢变为0；反之，$x * k$ 结果的小数位上不全为0，左移32位后便会出现在整数位上。<br>现在k的值为3264175145，与实际值3264175144.96有0.04的误差。若x是25的倍数，$x * k$ 的误差最高会达到 $0.04 * (2^{32}-1) &#x3D; 171798691.8$，所以 $&gt; 0$ 也就变为 $&gt; 171798691$，注意这里的运算结果类型均为<strong>整数</strong>；若x不是25的倍数，$x * k$ 的结果也一定会超过171798691，此项留给读者自行验证，实属巧妙！</p></blockquote><h3 id="寻找位运算的方法"><a href="#寻找位运算的方法" class="headerlink" title="寻找位运算的方法"></a>寻找位运算的方法</h3><p>不管怎么说，文章奇妙地构造了一种位运算形式 $((y * f) \&amp; m) &lt;&#x3D; t$，并通过Z3求解出 $0 ≤ y ≤ 102499$ 时 $f、m、t$ 的具体值，直接跳到它的证明部分，将<code>is_leap_year_fast</code>重写如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_leap_year_fast2</span><span class="params">(<span class="type">uint32_t</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> p = y * <span class="number">1073750999u</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> A = <span class="number">0b11000000000000000000000000000000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> B = <span class="number">0b00000000000000011111000000000000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> C = <span class="number">0b00000000000000000000000000001111</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p &amp; A) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p &amp; B) != B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p &amp; C) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(p &amp; A) !&#x3D; 0 triggers when (y % 4) !&#x3D; 0<br>1073750999u的二进制形式为0x01000000000000000010001111010111b，因此有<br>$p &#x3D; y * 1073750999u &#x3D; y * (0x01000000000000000000000000000000b + 0x10001111010111b)$<br><code>0x01000000000000000000000000000000b</code>将y的最低两位提为p的最高两位，同时<code>0x10001111010111b</code>最多影响到p的1-30位，结果得证。</p></blockquote><blockquote><p>(p &amp; C) &#x3D;&#x3D; 0 triggers when (y % 16) &#x3D;&#x3D; 0<br>显然，$(p \&amp; C) &#x3D;&#x3D; 0$ 成立时，$(p \% 16) &#x3D;&#x3D; 0$ 成立。又因为 $p &#x3D; y * 1073750999u$，而1073750999不会引入额外的因子2，所以 $(y \% 16) &#x3D;&#x3D; 0$ 成立，结果得证</p></blockquote><blockquote><p>(p &amp; B) !&#x3D; B triggers when (y % 100) !&#x3D; 0<br>之前的证明已经有<br>$p &#x3D; y * (0x01000000000000000000000000000000b + 0x10001111010111b)$<br>其中只有 $0x10001111010111b &#x3D; 9175$ 影响 $p \&amp; B$ 的结果。文章中编写程序进行穷举，发现 $0 ≤ y ≤ 102499$ 时，满足 $((y * 9175) \&amp; B) &#x3D;&#x3D; B$ 的 $y$ 包含*14、*57、*71、……、*00，其中除了*00外的其他数都在第一步被筛掉了，结果得证。</p></blockquote><p>接下来进一步从数学上解释</p><ol><li>为什么会捕获 *00<br>原文中提到<br>$$2^{17} ⋅ 7&#x2F;100 &#x3D; 9175.04 (exactly).$$<br>因此9175.04与*00相乘结果的1-17位均为0，同时9175与*00相乘的结果会比9175.04与*00相乘的结果稍小，那么9175与*00相乘会导致1-17为出现较多连续的1。以500为例<br>$$9175 * 500 &#x3D; 0x10001100000000000000000b − 500 ⋅ 0.04 &#x3D; 0x10001011111111111101100b$$<br>一般而言，减去的这个小数，即 $k00*0.04$，正好让13-17位变成了1，故而满足 $(p \&amp; B) &#x3D;&#x3D; B$。但如果这个小数超过 $2^{12} &#x2F; 0.04 &#x3D; 102400$，减去它之后会使得13-17 bit 不全为1，不满足 $(p \&amp; B) &#x3D;&#x3D; B$，这解释了 $y &lt; 102500$</li><li>为什么会捕获 *14、*57等 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = 2^17 * y * 0.r, B = 2^17 * 0.m</span><br><span class="line">p &amp; B 意味着 截断p高于17位的部分</span><br><span class="line">  p &amp; B == B  &lt;=&gt;  p 1-17位肯定覆盖 B </span><br><span class="line">  =&gt; p &gt;= B </span><br><span class="line">  &lt;=&gt; frac&#123;y*0.r&#125; &gt;= 0.m</span><br><span class="line">  &lt;=&gt; frac&#123;100*y*0.r&#125; mod 100 &gt;= 100*0.m</span><br><span class="line">带入0.r和0.m后，我们便有6.999969482421875y mod 100 ≥ 96.875</span><br></pre></td></tr></table></figure>对于 $y &#x3D; *00$，有 $7y mod 100 &#x3D;&#x3D; 0$，现在 $6.999…y mod 100$ 的结果会比100略小，因为存在误差 $\sigma&#x3D;7 − 6.999969482421875$。每次y增加100后，误差会不断累计，使得结果不断变小，当 $y &#x3D; (100 − 96.875) &#x2F; (7 − 6.999969482421875) &#x3D; 102400$ 后便会低于 96.875，这是 $y &lt; 102500$ 的另一种解释。<br>对于y &#x3D; *14、*71…，文章已解释详尽，不清楚的读者可自行了解乘法逆元、扩展欧几里得算法等概念再做理解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁：主动轮询型vs监听回调型</title>
      <link href="/Blog/2025/05/15/fen-bu-shi-suo-zhu-dong-lun-xun-xing-vs-jian-ting-xing/"/>
      <url>/Blog/2025/05/15/fen-bu-shi-suo-zhu-dong-lun-xun-xing-vs-jian-ting-xing/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍分布式锁的两种模型，共分三个章节，第一章节讲讲如何通过<code>redis</code>实现主动轮询型分布式锁；第二章节简要说下<code>etcd</code>中如何实现监听回调型锁，第三章节展示两种模型在不同场景下的性能比对与资源消耗情况。</p><span id="more"></span><p>并发场景中，“锁”用于对临界资源进行保护，让混乱的并发访问行为在临界区变为秩序的串行访问行为。在本地场景下，由于进程内线程可以共享进程数据，互斥锁的实现较为简单；而分布式场景下，我们需要跨域对多个物理节点执行加锁操作，故而需要依赖像<code>redis</code>、<code>mysql</code>等状态存储组件，在此基础上实现“分布式锁”。</p><h2 id="主动轮询型"><a href="#主动轮询型" class="headerlink" title="主动轮询型"></a>主动轮询型</h2><p>本节基于<a href="https://github.com/redis/go-redis">go-redis</a>，实现了单点模式下主动轮询模型的分布式锁，同时额外实现了“红锁”的基本功能，代码已放入笔者<a href="https://github.com/LuoZero-World/distributed-lock">Github仓库</a>。由于个人水平有限，如有不当之处，敬请谅解，并欢迎大家批评指正😊</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p><strong>创建分布式锁</strong><br>相比于创建锁，该操作更类似于“创建与锁的连接”，为简化操作叫法，下述一律使用“创建分布式锁”。代码中，结构体<code>RedisLock</code>中准备了将存储于<code>Redis</code>中的KV对，其中key字段用于唯一标识一把分布式锁，而value字段用于标识加锁的主体方身份，具体使用[主机IP+进程ID+ Go协程 ID]实现“身份绑定”</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RedisLock <span class="keyword">struct</span> &#123;</span><br><span class="line">    LockOptions</span><br><span class="line">    key    <span class="type">string</span></span><br><span class="line">    token  <span class="type">string</span> <span class="comment">// 表示分布式环境下[主机_进程_协程]想要获得此锁</span></span><br><span class="line">    client *redis.Client</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看门狗运行标识 0未运行 1正在运行</span></span><br><span class="line">    runningWatchDog <span class="type">int32</span></span><br><span class="line">    <span class="comment">//停止看门狗</span></span><br><span class="line">    stopWatchDog context.CancelFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRedisLock</span><span class="params">(key <span class="type">string</span>, client *redis.Client, opts ...LockOption)</span></span> *RedisLock &#123;</span><br><span class="line">    rLock := RedisLock&#123;</span><br><span class="line">    key:    REDIS_LOCK_KEY_PREFIX + key,</span><br><span class="line">    token:  utils.GenerateID(),</span><br><span class="line">    client: client,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    opt(&amp;rLock.LockOptions)</span><br><span class="line">    &#125;</span><br><span class="line">    repairLock(&amp;rLock.LockOptions)</span><br><span class="line">    <span class="keyword">return</span> &amp;rLock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>加锁</strong><br>加锁操作分为阻塞和非阻塞模式，可以在创建分布式锁时进行配置。非阻塞模式下，只会执行一次加锁尝试（<strong>SETNX操作保证原子性，不可重入</strong>），倘若失败，就直接返回错误；阻塞模式下，会通过计时器，每隔50 ms执行一次加锁尝试，如果某次请求加锁成功则直接返回，否则达到等锁超时阈值或者中途发生了预期之外的错误时终止流程。</p></li><li><p><strong>解锁</strong><br>解锁操作基于Lua脚本执行，保证操作的原子性。脚本执行时首先校验当前操作者是否拥有锁的所有权，是则解锁，否则返回错误</p></li></ol><h3 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h3><ol><li><p><strong>死锁问题</strong><br>客户端加锁后因进程崩溃、网络延迟等问题无法正常释放锁，导致锁永久不可用。可以在<code>Redis</code>中为每一条锁记录设置超时时间，加锁后超过这个时间锁便会自动释放，但是当业务实际处理时间超过超时时间时，业务处理方的锁会被自动释放，这显然是不合理的。<br>在<code>Redisson</code>中的解决方案是“<strong>看门狗策略</strong>”，在锁的持有方执行业务逻辑处理的过程中时，需要异步启动一个看门狗守护协程，持续为分布式锁的过期阈值进行延期操作。</p></li><li><p><strong>弱一致性问题</strong><br>避免单点故障引起数据丢失问题，<code>Redis</code>会基于主从复制的方式实现数据备份增加服务的容错性。为了保证服务的可用性和吞吐量，<code>Redis</code>在进行数据的主从同步时，采用的是异步执行机制。这种弱一致性同步就会导致，当使用方A在主节点加锁成功后，主节点突然宕机，数据还未同步至从节点，而后从节点升级为主节点造成锁记录丢失。<br>在<code>Redisson</code>中的解决方案是“<strong>红锁</strong>”，这是一种基于多<code>Redis</code>节点的分布式锁增强方案，通过向至少5个独立节点发起加锁请求并需获得半数以上成功响应来确保锁的互斥性，核心思想是<strong>通过多数派投票机制规避单节点故障风险</strong>。该方案网络开销较大且实现复杂，因此在多数情况下已被其他替代方案取代。</p></li></ol><h2 id="监听回调型"><a href="#监听回调型" class="headerlink" title="监听回调型"></a>监听回调型</h2><p>监听回调型锁在取锁失败时，并不会像主动轮询型锁持续请求锁，而是会监听锁的删除事件：当删除事件发生说明锁被释放了，此时才继续尝试取锁。<br>本节将重点分析监听回调型分布式锁的一个工程实践案例——<code>etcd</code>分布式锁。<a href="https://github.com/etcd-io/etcd">etcd</a>是一款适合用于共享配置和服务发现的分布式KV存储组件，底层基于分布式共识算法Raft协议保证了存储服务的强一致性和高可用。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p><strong>创建分布式锁</strong><br>结构体<code>Session</code>表示一次访问会话，背后对应的是一笔租约，用户调用<code>NewSession</code>方法构造<code>Session</code>实例时，首先申请到一个租约ID，然后<strong>异步开启一个守护协程，进行租约续期的相关处理</strong>。<br>结构体<code>Mutex</code>表示分布式锁，其中核心字段包括访问会话s、分布式锁的公共前缀pfx、pfx和租约ID拼接而成的锁使用方key字段myKey，以及锁使用方在pfx下对应的版本字段myRev</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">    client *v3.Client</span><br><span class="line">    opts   *sessionOptions</span><br><span class="line">    id     v3.LeaseID</span><br><span class="line"></span><br><span class="line">    cancel context.CancelFunc</span><br><span class="line">    donec  &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(client *v3.Client, opts ...SessionOption)</span></span> (*Session, <span class="type">error</span>) &#123;</span><br><span class="line">    lg := client.GetLogger()</span><br><span class="line">    ops := &amp;sessionOptions&#123;ttl: defaultSessionTTL, ctx: client.Ctx()&#125;</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(ops, lg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id := ops.leaseID</span><br><span class="line">    <span class="keyword">if</span> id == v3.NoLease &#123;</span><br><span class="line">        resp, err := client.Grant(ops.ctx, <span class="type">int64</span>(ops.ttl))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        id = resp.ID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithCancel(ops.ctx)</span><br><span class="line">    keepAlive, err := client.KeepAlive(ctx, id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || keepAlive == <span class="literal">nil</span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    donec := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    s := &amp;Session&#123;client: client, opts: ops, id: id, cancel: cancel, donec: donec&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep the lease alive until client error or cancelled context</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(donec)</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> keepAlive &#123;</span><br><span class="line">            <span class="comment">// eat messages until keep alive channel closes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    s *Session</span><br><span class="line">    </span><br><span class="line">    pfx   <span class="type">string</span></span><br><span class="line">    myKey <span class="type">string</span></span><br><span class="line">    myRev <span class="type">int64</span></span><br><span class="line">    hdr   *pb.ResponseHeader</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">(s *Session, pfx <span class="type">string</span>)</span></span> *Mutex &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Mutex&#123;s, pfx + <span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>加锁</strong><br>调用<code>Mutex.tryAcquire</code>方法尝试插入myKey，同时获取当前锁的实际持有者。如果当前锁从未被占用，或者锁持有者的版本号与调用方的版本号一致，则代表加锁成功；否则锁已被他人占用，调用<code>waitDeletes</code>方法，监听版本号小于自己且最接近于自己的锁记录数据的删除事件。当接收到解锁事件后，检查自身租约是否过期，没有则加锁成功</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">    resp, err := m.tryAcquire(ctx)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no key on prefix / the minimum rev is key, already hold the lock</span></span><br><span class="line">    ownerKey := resp.Responses[<span class="number">1</span>].GetResponseRange().Kvs</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ownerKey) == <span class="number">0</span> || ownerKey[<span class="number">0</span>].CreateRevision == m.myRev &#123;</span><br><span class="line">        m.hdr = resp.Header</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    client := m.s.Client()</span><br><span class="line">    <span class="comment">// wait for deletion revisions prior to myKey</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> early termination if the session key is deleted before other session keys with smaller revisions.</span></span><br><span class="line">    _, werr := waitDeletes(ctx, client, m.pfx, m.myRev<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// release lock key if wait failed</span></span><br><span class="line">    <span class="keyword">if</span> werr != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.Unlock(client.Ctx())</span><br><span class="line">        <span class="keyword">return</span> werr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the session is not expired, and the owner key still exists.</span></span><br><span class="line">    gresp, werr := client.Get(ctx, m.myKey)</span><br><span class="line">    <span class="keyword">if</span> werr != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.Unlock(client.Ctx())</span><br><span class="line">        <span class="keyword">return</span> werr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(gresp.Kvs) == <span class="number">0</span> &#123; <span class="comment">// is the session key lost?</span></span><br><span class="line">        <span class="keyword">return</span> ErrSessionExpired</span><br><span class="line">    &#125;</span><br><span class="line">    m.hdr = gresp.Header</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>监听</strong><br><code>waitDeletes</code>方法基于一个for循环自旋，每轮处理中会获取版本号小于自己且最接近于自己的加锁方key，如果key不存在，则说明自己的版本号已经是最小的，退出监听；否则调用<code>waitDelete</code>方法阻塞监听这个 key的删除事件。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitDeletes</span><span class="params">(ctx context.Context, client *v3.Client, pfx <span class="type">string</span>, maxCreateRev <span class="type">int64</span>)</span></span> (*pb.ResponseHeader, <span class="type">error</span>) &#123;</span><br><span class="line">    getOpts := <span class="built_in">append</span>(v3.WithLastCreate(), v3.WithMaxCreateRev(maxCreateRev))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        resp, err := client.Get(ctx, pfx, getOpts...)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(resp.Kvs) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> resp.Header, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastKey := <span class="type">string</span>(resp.Kvs[<span class="number">0</span>].Key)</span><br><span class="line">        <span class="keyword">if</span> err = waitDelete(ctx, client, lastKey, resp.Header.Revision); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitDelete</span><span class="params">(ctx context.Context, client *v3.Client, key <span class="type">string</span>, rev <span class="type">int64</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    cctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wr v3.WatchResponse</span><br><span class="line">    wch := client.Watch(cctx, key, v3.WithRev(rev))</span><br><span class="line">    <span class="keyword">for</span> wr = <span class="keyword">range</span> wch &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wr.Events &#123;</span><br><span class="line">            <span class="keyword">if</span> ev.Type == mvccpb.DELETE &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := wr.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := ctx.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;lost watcher waiting for delete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解锁</strong><br>直接删除调用方的KV对记录即可，如果调用方是持有锁的角色，那么删除KV对记录代表真正意义上的解锁动作；反之调用方并无持有锁，删除KV对就代表退出了抢锁流程，不会对流程产生负面影响。</p></li></ol><h3 id="技术难点-1"><a href="#技术难点-1" class="headerlink" title="技术难点"></a>技术难点</h3><p>1.<strong>死锁问题</strong><br><code>etcd</code>提供了租约机制，一旦达到租约上规定的截止时间，租约就会失去效力，这类似于<code>Redis</code>中的超时时间。同时，<code>etcd</code>中还提供了续约机制，用户可以通过续约操作来延迟租约的过期时间，这类似于<code>Redisson</code>中的看门狗策略。</p><p>2.<strong>惊群效应</strong><br>监听回调型锁的实现过程中，可能出现这样一种情况：如果一把分布式锁的竞争比较激烈，那么<strong>锁的释放事件可能同时被多个的取锁方所监听，一旦锁被释放后所有的取锁方都会一拥而上</strong>，然而一个轮次中只有一个取锁方能够取锁成功，因此这个过程中会存在大量性能损耗，且释放锁时刻瞬间激增的请求流量也可能会对系统稳定性产生负面效应。<br><code>etcd</code>中基于锁前缀和版本号机制提出的解决方案：对于对于同一把分布式锁，锁记录key拥有共同的前缀，作为锁的标识。加锁方加锁时，会以锁前缀拼接上自身租约ID，生成完整的key，因此<strong>加锁方key都是不同的</strong>，都能插入锁记录数据。每个加锁方插入锁记录数据时，会获得自身key处在锁前缀范围下唯一且递增的版本号。<strong>加锁方插入加锁记录数据不意味着加锁成功</strong>，而是需要在插入数据后查询一次锁前缀下的记录列表，判定自身key对应的版本号是否为其中最小，是则表示加锁成功；否则监听版本号小于自己但最接近自己的那个key的删除事件。<br>这样所有加锁方会<strong>根据版本号排成一条队列</strong>，每次锁释放只会惊动下一位，惊群问题得以避免。</p><h2 id="实验对比"><a href="#实验对比" class="headerlink" title="实验对比"></a>实验对比</h2><p>评价指标为平均加锁时间，即从发起锁请求到成功获取锁的平均时间、每秒成功加锁次数(LSPS)、P70&#x2F;P90&#x2F;P99延迟，以及CPU使用率差异。本节只展示宏观上的实验结论，不展示具体数值。</p><h3 id="延迟、吞吐量对比"><a href="#延迟、吞吐量对比" class="headerlink" title="延迟、吞吐量对比"></a>延迟、吞吐量对比</h3><p>在<strong>并发量较小，但加锁频繁</strong>的场景下，主动轮询型锁的平均加锁时间较低，但是<strong>长尾效应显著</strong>，约有10%的加锁时间为平均时间的10-20倍；而监听回调型锁的平均加锁时间在不断上升，每秒加锁成功数不断下降，说明其<strong>处理能力在逐渐下降</strong>，这可能是因为频繁请求使得etcd中事件堆积所致。<br>在<strong>并发量较大</strong>的场景下，主动轮询型锁的平均加锁时间随竞争数量线性增长，并且随着竞争程度的激烈，长尾效应愈发明显。同时客户端数量增加10倍，LSPS减少25%；监听回调型锁的平均加锁时间与LSPS并未随着竞争程度增加而明显变化，<strong>较为稳定</strong>。<br>但是两个场景下监听回调型锁的性能均劣于主动轮询型，这可能与笔者的实验环境仍处于单机状态有关，如不忽略<strong>节点间的通信延迟与实际任务处理时间</strong>，在高并发场景下监听回调型锁应该更具优势。</p><h3 id="资源消耗对比"><a href="#资源消耗对比" class="headerlink" title="资源消耗对比"></a>资源消耗对比</h3><p>监听回调型锁的CPU使用率约比主动轮询型锁约低10%-15%，在锁竞争激烈时CPU使用率的差距更加明显</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="/Blog/2025/02/23/suan-fa-mo-ban/"/>
      <url>/Blog/2025/02/23/suan-fa-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p><strong>感悟：<strong>回溯必须有终止条件，最好为</strong>边界判断</strong>和其他一些逻辑判断（即判断不符合要求的情况），这会很方便后面回溯的进行；当然，回溯前也可以进行判断，以免进行不必要的回溯。</p><p><strong>找子集：</strong> 从当前idx开始添加+isV；<strong>全排列：</strong> 从0开始添加+isV；当有重时，记住：若isV中上一个已经搜索完其子递归树，且这一个和上一个值相等，那么这一个没有继续递归的必要。p.s.全排列还可以通过交换的方式获得，但这时不好去重</p><blockquote><p>Minimax 算法中的 Alpha-Beta 剪枝</p></blockquote><p>利用搜索树每个节点取值的上下界来进行剪枝优化，注意点：</p><ol><li>每个节点具有<strong>最大下界</strong>和<strong>最小上界</strong>，且每个节点向上层节点返回自己的计算结果</li><li>上层节点以自己的上下界来<strong>初始化</strong>下层节点的上下界，最初以±∞表示</li><li>Min节点改变上界(Beta)，Max节点改变下界(Alpha)</li><li>一旦某节点<strong>上下界矛盾</strong>，进行剪枝</li></ol><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启了路径压缩和按秩合并的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">// 当前连通分支数目</span></span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无秩 并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点tree[x]覆盖的长度为lowbit(x),其父节点为tree[x+lowbit(x)]</span></span><br><span class="line"><span class="comment">// 上来先把三个方法写出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">binIndexedTree</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化「树状数组」，要默认数组是从 1 开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">binIndexedTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">      tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询前缀和的方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在树状数组 x 位置中增加值 u</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tree.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：<strong>树状数组动态维护</strong>前缀和</strong>，可单点修改，单点查询，区间查询；<strong>区间修改什么的，还是用线段树吧（若只有区间修改可以差分+树状）</strong></p><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//acwing 789</span></span><br><span class="line"><span class="comment">//找一个数在数组中的起始与结束位置</span></span><br><span class="line"><span class="type">int</span>[] binSearch(<span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//找起始位置</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; num) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">0</span>] = arr[l] == num ? l : -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找末位置</span></span><br><span class="line">    l = <span class="number">0</span>; r = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; num) r = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">1</span>] = arr[l] == num ? l : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：<strong>二分查找，<strong>先确定查找的参数</strong>是哪一个，确定两个区间，再确定使用二分产生的开销能否接受（往往与O(n)遍历结合）；&#x3D;&#x3D;二分查找的</strong>本质</strong>是查找<strong>具有二段性</strong>的区间的端点 &#x3D;&#x3D;，因此有两个模板，按需使用</p><p><strong>浮点数二分，</strong> 由于每次<code>mid</code>不会和<code>l、r</code>重复，因此不用担心无限循环问题，<code>while</code>判断条件往往为<code>l-r &lt;= 1e-m</code>，<code>m</code>根据经验，一般为所需精度减2</p><hr><h3 id="Manachar"><a href="#Manachar" class="headerlink" title="Manachar"></a>Manachar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">//构造马拉车字符串</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">preProcess</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;^$&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">&quot;#&quot;</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">T</span> <span class="operator">=</span> preProcess(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> T.length(), res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//马拉车字符串各字母的回文半径</span></span><br><span class="line">    <span class="type">int</span>[] P = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i_mirror</span> <span class="operator">=</span> <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res统计所有的回文子串</span></span><br><span class="line">        res += P[i]/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：</strong> Manachar算法前置须知：马拉车字符串的回文半径&#x3D;原字符串中对应回文串长度  从马拉车字符串的C位置推得原串中起始位置：start&#x3D;(Cindex-P[C])&#x2F;2;</p><p>然后就可以通过遍历依次求出对应字母的回文半径，需要动态维护<strong>最长右界R和最长右界的中心C，<strong>然后根据</strong>回文串内</strong>的对称性推当前字母回文半径。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串s 模式串p 均从下标1开始</span></span><br><span class="line"><span class="type">char</span>[] s, p;</span><br><span class="line"><span class="type">int</span>[] next;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">//重点在于，比较的是下一个字符！所以j+1,而i已经表示下一个字符</span></span><br><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">        <span class="comment">//匹配成功一次</span></span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左侧最近 严格小于 位置</span></span><br><span class="line"><span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//从左往右</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.isEmpty() &amp;&amp; left[st.peek()] &gt;= left[i]) st.pop();</span><br><span class="line">    <span class="comment">//通常存储索引</span></span><br><span class="line">    left[i] = st.isEmpty() ? -<span class="number">1</span> : st.peek();</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典用例: 滑动区间求最值</span></span><br><span class="line"><span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果一次进入一个元素，第一句的while可换成if</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;   <span class="comment">//队尾元素出队列</span></span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ps.单调队列在上面的dp多重背包问题中应用*/</span></span><br></pre></td></tr></table></figure><p><strong>感悟：<strong>单调队列和单调栈中的元素，顾名思义都是单调的，因此可以在其中进行</strong>二分</strong>、<strong>求极值</strong>等操作。</p><hr><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>用处：<strong>判断树中一个节点是否是另外一个节点的祖先节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录dfs一棵树时,每个节点的进入时间和退出时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="type">int</span>[] in, out;</span><br><span class="line">    <span class="type">int</span> clock;</span><br><span class="line">    <span class="comment">//leetcode 2322为例子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">        <span class="comment">//根据edges建树</span></span><br><span class="line">        Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">            g[x].add(y);</span><br><span class="line">            g[y].add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入时间</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//退出时间</span></span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入当前遍历到的节点x,和其父节点y</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">        in[x] = ++clock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y : g[x])&#123;</span><br><span class="line">            <span class="comment">//y需要是x的子节点</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        out[x] = clock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断n1是否是n2的祖先节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isParent</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(in[n1] &lt; in[n2] &amp;&amp; out[n2] &lt;= out[n1]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：<strong>dfs遍历时每个节点只会遍历一次，根据</strong>父子关系</strong>避免了遍历以及遍历过的节点；当然我们也可以设置 isVisited[] 来避免</p><hr><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ol><li>跳表是可以实现二分查找的有序链表</li><li>每个元素插入时随机生成它的level <strong>（索引层数，最底层为1）</strong></li><li>最底层包含所有的元素</li><li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li><li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li></ol><hr><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>一维差分数组求原数组，通过前缀和得到；二维自然也是求二维前缀和：即从矩阵左上角开始算起，到当前位置所围成小差分矩阵内的数字和。</p><p>区域改变时的规则：</p><img src="/Blog/img/0fe56b8bd48550b327275f6d9cdf35e7.jpg" alt="微信图片_20230313103218.jpg" style="zoom:50%;" /><hr><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>将题目中所有给出的数字，<strong>排序去重</strong>，再映射到<code>1 ~ n</code>的区间中，因此需要借助<strong>二分查找</strong>得到区间位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unique</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> waitTodc.size(), res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(waitTodc.get(i) != waitTodc.get(i-<span class="number">1</span>)) &#123;</span><br><span class="line">          waitTodc.set(res, waitTodc.get(i));</span><br><span class="line">          res++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找映射后的区间位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= waitTodc.get(mid)) r = mid;</span><br><span class="line">      <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛除每个质数的倍数 O(nlog(logn))</span></span><br><span class="line"><span class="comment">//n*(1/1+1/2+...1/n)</span></span><br><span class="line"><span class="type">int</span>[] primes;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">boolean</span>[] st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">      primes[cnt++] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据每个数的最小质因子，筛除每个合数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; primes[j] &lt;= n/i; j++)&#123;</span><br><span class="line">      <span class="comment">//primes[j] 一定是 primes[j]*i 的最小质因子</span></span><br><span class="line">      st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">//去掉这句就是埃氏筛法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示1~n中和n互质的数的个数</span></span><br><span class="line"><span class="comment">//n*(1-1/p1)*(1-1/p2)*...(1-1/pm) ,p1、...pm均为质因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phi</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);  <span class="comment">//(i-1)/i * res</span></span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//因为for循环退出后只遍历了比sqrt(x)小的质因数，因此还可能留下一个质因数</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可通过线性筛法求欧拉函数，这里不再列举</strong></p><p><strong>欧拉定理：</strong> $a^{phi(n)} &#x3D; 1 (modn)$，其中<code>a、n</code>互质</p><p><strong>费马定理：</strong>$a^{n-1}&#x3D;1(modn)$，欧拉定理的基础上，<code>n</code><strong>又是质数</strong></p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质就是将待求数a^n拆成a^1*a^2*...*a^(2^logn)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">qmi</span><span class="params">(<span class="type">long</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">      <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>((b&amp;<span class="number">1</span>) == <span class="number">1</span>) res = res*a%p;</span><br><span class="line">          a = a*a%p;</span><br><span class="line">          b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res%p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><em>前置知识：</em></p><ol><li><p>&#x3D;&#x3D;乘法逆元&#x3D;&#x3D;        <img src="/Blog/img/010e58fd12336484c1f9c64e155e4db2.png" alt="screen-capture" style="zoom:50%;" /></p><p>当<code>n</code>为质数时，根据<strong>费马定理</strong>，可知$a^{n-2}$即为<code>a</code>的乘法逆元，便不需扩展欧几里得</p></li><li><p>&#x3D;&#x3D;扩展的欧几里得算法&#x3D;&#x3D;</p><ol><li><p>最大公约数表示定理（<strong>裴蜀定理</strong>）</p><p><img src="/Blog/img/7dca99e400eabad2c0ab33d8f611ce1b.png" alt="screen-capture"></p></li><li><p>扩展欧几里得算法</p><p>在执行欧几里得算法时，利用每一步计算的余数和商，迭代的计算每一步的<code>s</code>和<code>t</code>，最后求出$s_n、t_n$</p><p><strong>用之求乘法逆元</strong>    <img src="/Blog/img/f33f00e05f3daca129317f39dc85b606.png" alt="screen-capture" style="zoom:50%;" /></p></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中国剩余定理</span></span><br><span class="line"><span class="comment">//m1, m2, ..., m_n 两两互质，则下述同余方程组必有唯一解集</span></span><br><span class="line"><span class="comment">//如果存在不互质的m_j，则无需理会那一个同余方程</span></span><br><span class="line"><span class="comment">//              x≡a1( mod m1)</span></span><br><span class="line"><span class="comment">//              x≡a2( mod m2)</span></span><br><span class="line"><span class="comment">//              ...</span></span><br><span class="line"><span class="comment">//              x≡a_n( mod m_n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRT</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>[] mod, remainder;</span><br><span class="line">  <span class="type">long</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//M = sum(m1, m2, ..., m_n)</span></span><br><span class="line">  <span class="comment">//remainder = [a1, a2, ..., a_n]</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CRT</span><span class="params">(<span class="type">int</span>[] mod, <span class="type">int</span>[] remainder)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.mod = mod;</span><br><span class="line">    <span class="built_in">this</span>.remainder = remainder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m : mod) M *= m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//求 (mod m)下的解，易知该解唯一</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">solute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mod.length;</span><br><span class="line">    <span class="type">long</span>[] mod_k = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) mod_k[i] = M/mod[i];</span><br><span class="line">    <span class="comment">//求mod_k中各元素 逆元</span></span><br><span class="line">    <span class="type">long</span>[] inverseE = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) inverseE[i] = (exgcd(mod_k[i], mod[i]))[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      res += (remainder[i]*mod_k[i]*inverseE[i]) ;</span><br><span class="line">      res %= M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回 [0] [1], 使得a*[0]+b*[1] = gcd(a, b)</span></span><br><span class="line">  <span class="type">long</span>[] exgcd(<span class="type">long</span> a, <span class="type">long</span> b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0L</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">long</span>[] res = exgcd(b, a%b);</span><br><span class="line">    <span class="comment">//b*[0] + (a-(a/b)*b)*[1] = gcd(a, b)</span></span><br><span class="line">    <span class="comment">//a*[1] + b*([0]-(a/b)*[1]) = gcd(a, b)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;res[<span class="number">1</span>], res[<span class="number">0</span>] - a/b*res[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><ol><li><strong>递推：</strong>$C_a^b&#x3D;C_{a-1}^b+C_{a-1}^{b-1}$，<code>O(n^2)</code></li><li>**预处理：**求出所有阶乘，以及所有阶乘的逆元（模p），<code>O(nlogn)</code></li><li><strong>卢卡斯定理：</strong>$C_a^b&#x3D;C_{a%p}^{b%p}*C_{a&#x2F;p}^{b&#x2F;p}$， <code>O(logp[n]*p)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">lucas</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> C(a, b);</span><br><span class="line">  <span class="keyword">return</span> C(a%p, b%p) * lucas(a/p, b/p) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>质数相乘：<strong>用于在</strong>不取模</strong>的情况下求解高精度答案</li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><p>前置思考：设置状态（<strong>变量越多，维度越高；根据最后一步推测</strong>）；有无<strong>后效性</strong>（即某一特定状态转移时，是否受前置状态的条件约束）；边界判断、初始化</p></li><li><p>线性动态规划 </p><p><strong>子序列（不一定连续）：dp[i]表示考虑前i个元素…</strong></p><p><strong>子串、子数组（连续）：dp[i]表示以第i个元素结尾…</strong></p><p><strong>有正负、上升下降等：0，1区分，进行转移</strong></p><p>目前发现特例 <em>最长上升子序列</em></p></li><li><p><strong>闫氏DP分析</strong></p><p><img src="/Blog/img/91996e0c978552cd355532b2369211f5.jpg" alt="4B8264F9FC5BA563A2B3B5A16981A353.jpg"></p></li><li><p><strong>时间复杂度：</strong> 状态个数 * 转移个数</p></li></ul><br/><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>常用$dp[i][j]$表示<strong>前i个物品在容量不超j</strong>的情况下的最大价值</p><ol><li><p><strong>01背包</strong></p><p>强调<strong>每件物品只能选择一次</strong>，一维空间优化时<strong>从大到小</strong>遍历</p></li><li><p><strong>完全背包</strong></p><p>强调<strong>每件物品可以无限选择</strong></p><p>一维空间优化时，通过换元可达到降低时间复杂度的效果，但要<strong>从小到大</strong>遍历</p></li><li><p><strong>多重背包</strong></p><p>强调<strong>每件物品只能选有限次</strong></p><p> 一维空间优化有：</p></li><li><p>二进制优化 (退化为01背包)、</p><p><strong>e.g. 容量1价值1 有7个 -&gt; 容量1价值1+容量2价值2+容量4价值4</strong></p></li><li><p><strong>单调队列</strong>优化 按余数从小到大遍历</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调队列维护</span></span><br><span class="line"><span class="comment">//控制队列大小-&gt;根据队列维护的最值来进行操作 e.g. dp -&gt;更新队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">//数量s,体积v,价值w</span></span><br><span class="line">  <span class="comment">//有N个物品,求在C的空间内的最大价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> C, <span class="type">int</span>[] s, <span class="type">int</span>[] v, <span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>]; <span class="comment">// 记录上一次的结果</span></span><br><span class="line">        <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>]; <span class="comment">// 优先队列，动态维护 潜力从大到小的!容量!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> v[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">wi</span> <span class="operator">=</span> w[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> s[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上次算的结果存入辅助数组中</span></span><br><span class="line">            g = dp.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 枚举余数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vi; j++) &#123;</span><br><span class="line">                <span class="comment">// 初始化队列，head 和 tail 分别指向队列头部和尾部</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>, tail = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 枚举同一余数情况下，有多少种方案。</span></span><br><span class="line">                <span class="comment">// 例如余数为 1 的情况下有：1、vi + 1、2 * vi + 1、3 * vi + 1 ...</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt;= C; k+=vi) &#123;</span><br><span class="line">                    dp[k] = g[k];</span><br><span class="line">                    <span class="comment">// 将不在窗口范围内的值弹出</span></span><br><span class="line">                    <span class="keyword">if</span> (head &lt;= tail &amp;&amp; q[head] &lt; k - si * vi) head++;</span><br><span class="line">                    <span class="comment">// 如果队列中存在元素，直接使用队头来更新</span></span><br><span class="line">                    <span class="keyword">if</span> (head &lt;= tail) dp[k] = Math.max(dp[k], g[q[head]] + (k - q[head]) / vi * wi);</span><br><span class="line">                    <span class="comment">// 当前值比对尾值更优，队尾元素没有存在必要，队尾出队</span></span><br><span class="line">                    <span class="comment">// 用减法 表明两者都是从dp[k]转移而来</span></span><br><span class="line">                    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / vi * wi &lt;= g[k] - (k - j) / vi * wi) tail--;</span><br><span class="line">                    <span class="comment">// 将新下标入队 </span></span><br><span class="line">                    q[++tail] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[C];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>分组背包</strong></p><p>强调<strong>每组物品中只能选一个物品</strong>，因此以当前这一组物品中选哪个物品作为划分子集的依据，进行状态转移</p></li></ol><br/><h3 id="数字三角形dp"><a href="#数字三角形dp" class="headerlink" title="数字三角形dp"></a>数字三角形dp</h3><p>二维数组，左上到右下，求路径最大值</p><p><strong>现在扩展到两条路径，但一个方格的数只能取一次，求路径最大值</strong></p><p>状态设置<code>f[i1, j1, i2, j2]</code>，代表两条路径当前停留的位置，每条路径可从上、左两方向转移，因此<strong>两条路径下</strong>有<strong>四种</strong>转移状态。</p><p>如何解决所走方格会不会重复？当<code>i1+j1=i2+j2</code>成立时，两条路径的当前停留位置<strong>可能</strong>重复。因此我们可以认为这两条路径<strong>同时</strong>从左上出发，步频一致，那么状态可简化为<code>f[k, i1, i2]</code>，其中<code>k=i1+j1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= <span class="number">2</span>*n; k++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt;= n; i1++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>; i2 &lt;= n; i2++)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> k-i1, j2 = k-i2;</span><br><span class="line">        <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> w[i1][k-i1];</span><br><span class="line">          <span class="comment">//不重复</span></span><br><span class="line">          <span class="keyword">if</span>(i1 != i2) t += w[i2][k-i2];</span><br><span class="line">          <span class="comment">//下 下</span></span><br><span class="line">          f[k][i1][i2] = f[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2-<span class="number">1</span>]+t;</span><br><span class="line">          <span class="comment">//下 左</span></span><br><span class="line">          f[k][i1][i2] = Math.max(f[k][i1][i2], f[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2]+t);</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">2</span>*n][n][n];</span><br></pre></td></tr></table></figure><br/><h3 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h3><p>**tip：**当结果需要多个统计<code>f[][]</code>的值时，不妨让<code>f</code>的第一个维度<code>+1</code>，然后结果直接可以是<code>f[n+1][]</code></p><br/><h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p><strong>tip：<strong>若区间为</strong>环</strong>，可将环展开为链，并将链长扩展一倍</p><br/><h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><blockquote><p>找树的直径（边权均为正）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 任取一点做为起点，找到距离该点最远的一个点u</span><br><span class="line">(可证明该点一定是某条直径的端点)</span><br><span class="line">2. 再找到距离u的最远的一点</span><br></pre></td></tr></table></figure><p><strong>若包含负权边</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应该枚举全部路径，找出最大长度</span></span><br><span class="line"><span class="comment">//  将所有路径按点分类(点可视为根，因为图为无向图，所以每个点都可作为根)</span></span><br><span class="line"><span class="comment">//  那么枚举所有点，对于每个点再枚举以其为根的树的直径即可</span></span><br><span class="line">dfs(<span class="type">int</span> node, <span class="type">int</span> fa)&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//表示向下走的最长距离</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0</span>, d2 = <span class="number">0</span>    <span class="comment">//最大值和次大值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="comment">/*遍历node的每一个相邻节点 snode*/</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(snode == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> dfs(snode, node) + <span class="comment">/*node -&gt; snode 的距离*/</span></span><br><span class="line">    dist = Math.max(dist, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(d &gt;= d1) d2 = d1, d1 = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2) d2 = d;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = Math.max(ans, d1+d2);     <span class="comment">//d1+d2即为以node为根的树的直径</span></span><br><span class="line">  <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>换根dp</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 指定任意一个根节点</span><br><span class="line">2. 一次dfs遍历，统计出当前子树内的节点对当前节点的贡献</span><br><span class="line">3. 一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案</span><br><span class="line">具体题目见&lt;编程题&gt;中的&lt;树的中心&gt;</span><br></pre></td></tr></table></figure><br/><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p>对于任意给定序列，其<strong>最长上升子序列长度</strong>等于使用<strong>非上升子序列</strong>将整个序列覆盖的<strong>最小数量</strong>，因为两者的贪心做法完全相同（Dilworth定理）</p><br/><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idx 当前判断到哪一位</span></span><br><span class="line"><span class="comment">//mask 标记哪些已经用过</span></span><br><span class="line"><span class="comment">//isLimit 当前位是否受到约束 如果前几位均和n前几位等同则收到约束，否则最大可9</span></span><br><span class="line"><span class="comment">//isJump 是否可以跳过 用于限制首发数字不为0</span></span><br><span class="line"><span class="comment">//函数表示 构造从高到低第 idx 位及其之后数位的合法方案数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isJump)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == s.length) <span class="keyword">return</span> isJump ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//可以记忆化搜索的情况：不受限</span></span><br><span class="line">    <span class="comment">//因为受限和不受限的情况下，dp值不同，但受限情况下dp值唯一</span></span><br><span class="line">    <span class="keyword">if</span>(!isLimit &amp;&amp; <span class="comment">/* !isJump &amp;&amp; */</span>dp[idx][mask] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[idx][mask];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isJump) res = f(idx+<span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> isJump ? <span class="number">1</span> : <span class="number">0</span>, up = isLimit ? 受限值 : <span class="number">9</span>; d &lt;= up; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((mask &gt;&gt; d) &amp; <span class="number">1</span>) == <span class="number">0</span>) </span><br><span class="line">            res += f(idx+<span class="number">1</span>, mask|(<span class="number">1</span> &lt;&lt; d), isLimit &amp;&amp; d == up, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!isLimit <span class="comment">/* &amp;&amp; !isJump */</span>) dp[idx][mask] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//伪代码模板</span><br><span class="line">//可选参数-具体题目具体分析 pre：上一位 lead：前导0是否存在 </span><br><span class="line">//cnt:某些数字出现的次数 sum:搜索到当前某数字之和</span><br><span class="line">int N = 最长位数;</span><br><span class="line">int dp[N][N], a[N];</span><br><span class="line">int dfs(int pos, /*可选参数 int pre, int lead,*/int limit) &#123;</span><br><span class="line">    if (!pos) &#123;</span><br><span class="line">        边界条件(有时直接 return 1)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre];</span><br><span class="line">    int res = 0, up = limit ? a[pos] : 无限制位;</span><br><span class="line">    for (int i = 0; i &lt;= up; i ++) &#123;</span><br><span class="line">        if (不合法条件) continue;</span><br><span class="line">        res += dfs(pos - 1, 未定参数, lead &amp;&amp; !i, limit &amp;&amp; i == up);</span><br><span class="line">    &#125;</span><br><span class="line">    return limit ? res : (lead ? res : dp[pos][sum] = res);</span><br><span class="line">&#125;</span><br><span class="line">int cal(int x) &#123;</span><br><span class="line">    memset(dp, -1, sizeof dp);    </span><br><span class="line">    len = 0;</span><br><span class="line">    while (x) a[++ len] = x % 进制, x /= 进制;</span><br><span class="line">    return dfs(len, 未定参数, 1, 1);</span><br><span class="line">&#125;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：</strong> 数位dp经常用于<strong>状态压缩</strong>，此时不再是线性dp，很难用for循环遍历（动态规划本质上是求解的一种<strong>拓扑序</strong>），因此就用到<strong>记忆化搜索</strong>(e.g. LCP69)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>在迭代版的前、中、后序遍历中，弹栈的目的就是找到当前节点的“后续”节点。而Morris算法，就是在遍历的过程中**“线索化”**，从而优化了栈空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Morris中序遍历为例</span></span><br><span class="line"><span class="comment">//线索化：找predecessor --&gt; predecessor.right = root</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 cur 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor.right != <span class="literal">null</span> &amp;&amp; predecessor.right != cur) &#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    predecessor.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    predecessor.right = <span class="literal">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="comment">//还可以添加word字段 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免查找和查头的代码重复</span></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：<strong>主要用于</strong>处理前缀</strong>以及词频统计</p><p><strong>易错：</strong> 存在word字段 并在insert()中要修改它时，切记修改的是当前节点的word字段，写法应该是<code>node.word = ...</code> ，容易错写为<code>word = ...</code></p><br/><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="邻接表存储-三数组"><a href="#邻接表存储-三数组" class="headerlink" title="邻接表存储(三数组)"></a>邻接表存储(三数组)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdjacencyList</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] e, next, head;</span><br><span class="line">    <span class="type">boolean</span>[] v;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, n;            <span class="comment">//仅代表当前数组存放的下标，与node值无关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//n个节点 ：1-n</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdjacencyList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> n+<span class="number">5</span>;</span><br><span class="line">        e = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N];      <span class="comment">//e[idx]=node</span></span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N];    <span class="comment">//next[idx] = idx2</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">int</span>[N];    <span class="comment">//head[node] = idx</span></span><br><span class="line">        v = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边 n1-&gt;n2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        e[idx] = n2;</span><br><span class="line">        next[idx] = head[n1];       <span class="comment">//向头添加</span></span><br><span class="line">        head[n1] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">        v[node] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[node]; i != -<span class="number">1</span>; i = next[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node2</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[node2])&#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接上</span></span><br><span class="line"><span class="comment">//q[] 模拟队列  d[node]代表节点入度</span></span><br><span class="line"><span class="comment">//判断是否有拓扑序  执行完q中序列即为拓扑序(如果有的话)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">topoSort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;        <span class="comment">//队头队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[n] == <span class="number">0</span>) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[t]; i != -<span class="number">1</span>; i = next[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> e[i];</span><br><span class="line">            d[node]--;</span><br><span class="line">            <span class="keyword">if</span>(d[node] == <span class="number">0</span>) q[++tt] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tt == n-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h3><p><img src="/Blog/img/1e1e6cd6cf3298e009c6e8fb2fbc7ab7.jpg" alt="IMG_20230327_201754.jpg"></p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于稠密图</span></span><br><span class="line"><span class="type">int</span>[][] g;  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span>[] dist;  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = Math.min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总得来看，寻找最小点需要</strong>$O(n^2)$，<strong>更新节点距离需要</strong>$O(m)$，因此在面对<strong>稀疏图</strong>时，我们可以使用优先队列提高寻找最小点的速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, idx;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span>[] h, w, e, ne;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span>[] dist;        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] t = heap.poll();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ver</span> <span class="operator">=</span> t[<span class="number">1</span>], distance = t[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ver == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[ver]; i != -<span class="number">1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于不需要用不到边与边的关系，因此可以直接用一个多维数组或者类来存储</span></span><br><span class="line"><span class="comment">//这里仍然用邻接表存储</span></span><br><span class="line"><span class="type">int</span>[] e, ne, h, w, dist;</span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, n, m, k;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Bellmanford</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//遍历k次 每遍历一次延申一次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">      <span class="comment">//防止串联现象(一次遍历中延申了多次)</span></span><br><span class="line">      <span class="type">int</span>[] dist2 = Arrays.copyOf(dist, n+<span class="number">5</span>);</span><br><span class="line">      <span class="comment">//每次都遍历一遍所有边</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>; n1 &lt;= n; n1++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h[n1]; j != -<span class="number">1</span>; j = ne[j])&#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> e[j], del = w[j];</span><br><span class="line">              <span class="keyword">if</span>(dist[n2] &gt; dist2[n1]+del)&#123;</span><br><span class="line">                  dist[n2] = dist2[n1]+del;</span><br><span class="line">              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//因为有负权边，所以不能通过返回-1来判断找到与否</span></span><br><span class="line">  <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于Bellman-Ford,我们想到每次不需要遍历所有的边</span></span><br><span class="line"><span class="comment">//使用队列，遍历那些刚更新过值的边的后继，这便是宽搜优化</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">spfa</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        st[v] = <span class="literal">false</span>;      <span class="comment">//表示当前点是否在队列中，Dijkstra中代表是否在最短集中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[v]; i != -<span class="number">1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[v] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[v] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.offer(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(dist[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过SPFA判断负环：</strong> 另开辟数组<code>cnt</code>，记录从源点到达当前点所经过的<strong>路径数</strong>，当且只当<code>dist</code>更新时才更新<code>cnt</code>。因此如果出现<code>cnt</code>中某个值大于<strong>总点数</strong>，根据容斥原理，必然存在负环。</p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p><strong>思想：</strong> 基于动态规划，<code>d[k][i][j]</code>表示在只经过前<code>k</code>个节点所构成的路径的前提下，从节点<code>i</code>到节点<code>j</code>的最短距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化最高维</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &gt; d[i][k]+d[k][j]) d[i][j] = d[i][k]+d[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><img src="/Blog/img/8f20a5322f5e22b82669ec3724f5d27d.jpg" alt="529c3138e9bb91b0fc0f9e74856df0a.jpg"></p><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p><strong>思想：</strong> 同<em>dijkstra</em>，每次遍历都是找一个距离最近的点加入集合，但是这里的距离最近是指点距离整个集合的距离最近，因此更新<code>dist[]</code>时需要注意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] g;      <span class="comment">//距离矩阵</span></span><br><span class="line"><span class="type">int</span>[] dist;     <span class="comment">//每个点与集合的距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span><span class="params">()</span>&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//添加n次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minv</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (minv == -<span class="number">1</span> || dist[j] &lt; dist[minv])) minv = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[minv] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//找不到合适的点，无法构造</span></span><br><span class="line">        <span class="keyword">if</span>(dist[minv] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dist[minv];</span><br><span class="line">        <span class="comment">//最后更新距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) dist[j] = Math.min(dist[j], g[minv][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//[a-&gt;b, w]</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//按权值从小到大排序</span></span><br><span class="line">    Collections.sort(lists, (a, b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要考虑两个点是否在同一个连通块中</span></span><br><span class="line">    <span class="type">UnionFind</span> <span class="variable">uset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] e = lists.get(i);</span><br><span class="line">        <span class="keyword">if</span>(uset.unite(e[<span class="number">0</span>], e[<span class="number">1</span>]))&#123;</span><br><span class="line">            res += e[<span class="number">2</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n-<span class="number">1</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法（求二分图最大匹配）"><a href="#匈牙利算法（求二分图最大匹配）" class="headerlink" title="匈牙利算法（求二分图最大匹配）"></a>匈牙利算法（求二分图最大匹配）</h3><p><strong>二分图当且仅当图中不含奇数环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] e, ne, h, matches;    <span class="comment">//n2集合中元素匹配到哪个n1集合中的元素</span></span><br><span class="line"><span class="type">int</span> idx, n1;</span><br><span class="line">Kattio kio;</span><br><span class="line"><span class="type">boolean</span>[] st;   <span class="comment">//对于当前n1集合中这个元素，相应n2集合中某个元素是否被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hungarian</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[u]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[v])&#123;</span><br><span class="line">            st[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matches[v] == <span class="number">0</span> || find(matches[v]))&#123;</span><br><span class="line">                matches[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启发式搜索：A"><a href="#启发式搜索：A" class="headerlink" title="启发式搜索：A*"></a>启发式搜索：A*</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以网格寻路为例 start-&gt;goal</span></span><br><span class="line">frontier = PriorityQueue()  </span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()  <span class="comment">#记录相邻节点的到达关系</span></span><br><span class="line">cost_so_far = <span class="built_in">dict</span>()  <span class="comment">#当前路径代价</span></span><br><span class="line">came_from[start] = <span class="literal">None</span> </span><br><span class="line">cost_so_far[start] = <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> current == goal:  <span class="comment">#精妙的一步</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">#遍历所有邻居(下一种情况)</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      new_cost = cost_so_far[current] + graph.cost(current, <span class="built_in">next</span>)</span><br><span class="line">      <span class="comment">#比较的是当前代价，而不是总代价！！！</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far[<span class="built_in">next</span>]:</span><br><span class="line">         cost_so_far[<span class="built_in">next</span>] = new_cost</span><br><span class="line">         <span class="comment">#总代价：当前代价+预估代价</span></span><br><span class="line">         priority = new_cost + heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算预估代价        </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heuristic</span>(<span class="params">a, b</span>):</span><br><span class="line">   <span class="comment"># Manhattan distance on a square grid</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y)</span><br><span class="line">   <span class="comment"># Chebyshev Distance</span></span><br><span class="line">   <span class="comment"># return Math.max(b.x, b.y)</span></span><br><span class="line">   <span class="comment"># Euclidean Distance</span></span><br><span class="line">   <span class="comment"># return Math.sqrt(Math.pow(a.x-b.x, 2)+Math.pow(a.y-b.y, 2))</span></span><br></pre></td></tr></table></figure><p><strong>感悟：</strong> <em>Dijkstra</em> + <em>Greedy Best First Search</em></p><p><strong>A star</strong>算法优点在于对环境反应迅速，搜索路径直接，是一种直接的搜索算法，因此被广泛应用于路径规划问题。其缺点是实时性差，每一节点计算量大、运算时间长，而且随着节点数的增多，算法搜索效率降低，<strong>而且A star算法并没有完全遍历所有可行解，所得到的结果不一定是最优解。</strong></p><p><strong>选对估值函数很重要，一般用切比雪夫距离</strong></p><br/><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="Gosper’s-Hack"><a href="#Gosper’s-Hack" class="headerlink" title="Gosper’s Hack"></a>Gosper’s Hack</h3><p>用处：生成 $n$ 元集合中的所有 $k$ 元子集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** e.g. GospersHack(2, 4) 依次生成：</span></span><br><span class="line"><span class="comment"> *  0011 0101 0110</span></span><br><span class="line"><span class="comment"> *  1001 1010 1100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GospersHack</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; limit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> cur &amp; -cur;  <span class="comment">//lowbit</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> cur + lb;   <span class="comment">//左半部分</span></span><br><span class="line">        cur = (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lb) | r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="数组元素位运算"><a href="#数组元素位运算" class="headerlink" title="数组元素位运算"></a>数组元素位运算</h3><p>该模板可以做到：</p><ol><li>求出<strong>所有子数组</strong>的按位或的结果，以及值等于该结果的子数组的个数。</li><li>求按位或结果等于<strong>任意给定</strong>数字的子数组的 最短长度&#x2F;最长长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode 2411</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestSubarrays(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">var</span> <span class="variable">ors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;(); <span class="comment">// 按位或的值 + 对应子数组的右端点的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ors.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            <span class="type">var</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> or : ors) &#123;</span><br><span class="line">                or[<span class="number">0</span>] |= nums[i];</span><br><span class="line">                <span class="keyword">if</span> (ors.get(k)[<span class="number">0</span>] == or[<span class="number">0</span>])</span><br><span class="line">                    ors.get(k)[<span class="number">1</span>] = or[<span class="number">1</span>]; <span class="comment">// 合并相同值，下标取最小的</span></span><br><span class="line">                <span class="keyword">else</span> ors.set(++k, or);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为是原地去重，所以要删除冗余的元素</span></span><br><span class="line">            <span class="comment">//也可以 ors.subList(0, k+1)，但耗时</span></span><br><span class="line">            </span><br><span class="line">            ors.subList(k + <span class="number">1</span>, ors.size()).clear();</span><br><span class="line">            <span class="comment">// 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找</span></span><br><span class="line">            ans[i] = ors.get(<span class="number">0</span>)[<span class="number">1</span>] - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="RMQ（区间最值）"><a href="#RMQ（区间最值）" class="headerlink" title="RMQ（区间最值）"></a>RMQ（区间最值）</h2><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><blockquote><p>ST 表是用于解决 可重复贡献问题 的数据结构。</p></blockquote><p><strong>算法思想：</strong> 基于倍增的思想，令<code>f[i][j]</code>代表区间$[i, i+2^j-1]$的最大值，转移方程也容写出：<code>f[i][j] = max(f[i][j-1], f[i+2^(j-1)][j-1])</code></p><p>对于每个询问<code>[l, r]</code>,因为问题<strong>可重复贡献</strong>，我们将其分为两部分求最大值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log函数预处理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pre</span><span class="params">()</span>&#123;</span><br><span class="line">        log2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">            log2[i] = log2[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)-<span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">            f[i][j] = op(f[i][j-<span class="number">1</span>], f[i+(<span class="number">1</span>&lt;&lt;(j-<span class="number">1</span>))][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">  <span class="comment">//核心代码</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">del</span> <span class="operator">=</span> log2[r-l+<span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> op(f[l][del], f[r-(<span class="number">1</span>&lt;&lt;del)+<span class="number">1</span>][del]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int q[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l &gt;= r) return;</span><br><span class="line">    //处理当前区间</span><br><span class="line">    int i = l - 1, j = r + 1, x = q[l+r+1 &gt;&gt; 1];    //注意是向上取整,因为向下取整可能使得x取到q[l]</span><br><span class="line">    while(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++; while(q[i] &lt; x);</span><br><span class="line">        do j--; while(q[j] &gt; x);</span><br><span class="line">        if(i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    //子区间分治</span><br><span class="line">    quick_sort(q, l, i - 1), quick_sort(q, i, r); //必须是 l~i-1 i~r，保证一个&lt;=x、一个&gt;=x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感悟：</strong> 边界问题太复杂，用时直接敲模板；<strong>快排本质</strong>就是分治，每一步分治的<strong>关键</strong>在于如何将所分区间<strong>分成两份</strong>，若划分标准是<code>x</code>，那么我们目标是将区间分为<code>&gt;= x</code>和<code>&lt;= x</code>两个部分。</p><p>首先说明两个游标<code>i、j</code>的含义：当循环结束时，<code>i</code>前面的<code>&lt;= x</code>（不是<code>&lt; x</code>），而包括<code>i</code>及其后面的<code>&gt;= x</code>；<code>j</code>同理。这也就解释了在子区间分治时的传参原因了。</p><p>再说<strong>边界问题</strong>：分治最怕<strong>无限分治</strong>，即将<code>n</code>分成<code>0</code>和<code>n</code>。所以当我们进行子区间分治时，若用<code>i</code>划分，则<code>x</code>不能选区间左值；若用<code>j</code>划分，则<code>x</code>不能选区间右值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g. 用 i 划分，选择区间左值作为 x，试试这个例子: [1 2]</span><br></pre></td></tr></table></figure><p>实际上，当待排序数组长度为2时才会出现无限递归，完全可以<strong>在数组长度小于某个阈值时，使用插入排序</strong>，以此来规避无限递归。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>囫囵吞枣与2024后记</title>
      <link href="/Blog/2025/01/12/hu-lun-tun-zao-yu-hou-ji/"/>
      <url>/Blog/2025/01/12/hu-lun-tun-zao-yu-hou-ji/</url>
      
        <content type="html"><![CDATA[<p>本科与研究生两个阶段的交接仪式，暂定于2024这一年。</p><p>仿佛天光乍破，本科四年已然成为了回忆，徐徐退场。趁着新的一切还未开始，趁着破晓时分仍弥留着的恍惚，像约定俗成的那样，同龄人们都踏上了这一场终末旅行。</p><span id="more"></span><p>于是便同舍友去了华清宫，爬上苍翠葱郁的骊山谈笑风生；坐车到青海湖、茶卡盐湖，穿着盐湖靴在“天与云与山与水，上下一白”间肆意漫步；之后领略到老君山上的道家底蕴、感叹鸡冠洞中的鬼斧神工、听闻白马寺里法音彻彻,香烟袅袅……</p><p>然后便穿上学士服，走上红毯，捧起毕业证书，在一片欢声笑语中，将自己定格在那一帧。相机灯光闪过，滤走了最后的一丝恍惚。</p><p>数声风笛离亭晚，君向潇湘我向秦。</p><p>时间来到夏季，以往是放暑假的日子。</p><p>跑步、撸铁、刷番，带着对研究生生活的期许，囫囵吞枣地，便度过了整个夏季。</p><p>但是彼时的我，还未意识到事情的严重性。现在看来，23年那篇末尾的东拉西扯，也并非全是无病呻吟。</p><p>再次开学，身份已经转变。什么从被动灌输到主动探索、什么从同心协力到踽踽独行……本科生到研究生的转变，天花乱坠、不胜枚举，仿佛成长只在一瞬间完成。</p><p>确实如此。研一上半年给我印象最深刻的是，要求同存异（狗头）。存什么异，只能说道不同不相为谋。</p><p>不如在此立一个25年的目标：完成毕业要求的一篇论文，拿到一份不错的实习！</p><p>事已至此，那就先当一个独行侠吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐推荐系统</title>
      <link href="/Blog/2024/06/12/yin-le-tui-jian-xi-tong/"/>
      <url>/Blog/2024/06/12/yin-le-tui-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<p><del><a href="http">演示传送门</a></del></p><p>毕设项目，因为中间要写各种各样的文档、论文改稿，导致慢慢悠悠敲了小两个月才完成。不过这也是我第一次没跟任何视频，独立实现的基于前后端分离的项目，技术栈当然是Vue SpringBoot SpringSecurity </p><span id="more"></span><p>感觉还是独立完成一个项目最能得到锻炼，因为项目推进过程中遇到的问题简直不胜枚举，有的即便平常有过了解，但见到时却仍然手足无措；有的就是“全新gang觉”。</p><p>那么是不是平时学的“完备”一点，做项目时就能“轻松”一些嘞？目前我的观点是：平时学框架，项目补细节。本质还是实践出真知，虽然课程或者博客中介绍的内容确实全面，但光看并不会提升什么（SpringSecurity过滤器链配置、拦截器、Nginx代理我看完根本不会用）。因此，还得通过痛苦的实践来加深记忆和理解，亲力解决问题必然会收获颇丰。</p><p>最令人抓狂的还是写前端页面，在项目开始前我先去b站刷了14个小时的Vue3快速入门，然后配合element-plus 的各种封装控件完善项目。但上手第三方封装库的代价就是需要不断读文档，不断试错，而且有时容易舍本逐末：因为封装控件不可控，选择原生控件配合CSS往往更佳。最后虽然没有用到Vue3 组合式的精髓，但至少达到了“会用”的水平。</p><p>开发过程冗长无味，下面着重介绍优化和部署时的重点坑点。</p><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><p>音乐推荐系统的后端存了每首歌曲的音频文件和封面图，占用了不少磁盘空间。原先的方式是前端发请求，后端返回Blob格式的数据，前端解析并存入Pinia 复用。</p><p>部署后发现图片加载速度太慢，于是用GitHub搭了个图床，配合jsDelivr 做CDN优化，加载耗时显著降低，而且后端也不需要存图片了，一举两得。</p><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>老早就听过Docker 的大名，这次正好拿来练练。</p><p>项目部署需要用到MySQL 、Redis 、Nginx 、JDK17 等支持，下载到服务器之后还需要各种配置，难以管理。而使用Docker 可以将它们作为一个个容器来进行部署和管理，容器之间相互隔离，无须配置便可直接运行，大大降低运维成本。</p><p>在Ubuntu上部署音乐推荐系统的步骤，大致为：</p><p>安装Docker</p><p>拉取镜像、组网配置</p><p>构建后端镜像</p><p>后端部署</p><p>前端部署</p><p>组网配置是为了让项目用到的几个容器之间可以相互通信，因此要将它们配置到同一网桥上。</p><p>构建后端镜像需要编写Dockerfile ,内容也很简单。</p><p>镜像部署一定要配置挂载路径，可在DockerHub上查看相关镜像文档来确定容器内部路径。如MySQL 镜像中的初始化文件存放路径&#x2F;docker-entrypoint-initdb.d；Nginx 镜像中前端文件存放路径&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html……</p><p>Nginx部署需要编写配置文件，用于代理打包好的前端项目；而在开发环境中，IDE直接将项目运行在Node.js 环境中，无须Nginx 。配置文件的关键部分如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听5173端口（Vue项目的运行端口）</span></span><br><span class="line">        <span class="attribute">listen</span>      <span class="number">5173</span>;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html/music_frontend；</span><br><span class="line">            <span class="comment"># 按需检索文件是否存在</span></span><br><span class="line">            <span class="comment"># 不添加这一项，刷新页面后报404</span></span><br><span class="line">            try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 请求转发</span></span><br><span class="line">        <span class="comment"># musicrs为后端容器名，这里代表地址</span></span><br><span class="line">        <span class="section">location</span> /api &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://musicrs:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>已经上传GitHub ，未来应该会加入Elasticsearch 用于歌曲搜索</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程设计模式</title>
      <link href="/Blog/2024/05/23/java-duo-xian-cheng-she-ji-mo-shi/"/>
      <url>/Blog/2024/05/23/java-duo-xian-cheng-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程评价标准"><a href="#多线程评价标准" class="headerlink" title="多线程评价标准"></a>多线程评价标准</h3><ul><li><p><strong>安全性</strong>——不损坏对象&#x3D;&#x3D;【必须】&#x3D;&#x3D;</p></li><li><p><strong>生存性&#x2F;活性</strong>——必要的处理能够被执行&#x3D;&#x3D;【必须】&#x3D;&#x3D;</p></li><li><p><strong>可复用性</strong>——类可重复利用，e.g. JUC</p></li><li><p><strong>性能</strong>——能快速、大批量处理：吞吐量、响应性、容量</p></li></ul><h3 id="I-Single-Threaded-Execution模式"><a href="#I-Single-Threaded-Execution模式" class="headerlink" title="I.Single Threaded Execution模式"></a>I.Single Threaded Execution模式</h3><p>该模式会将修改或引用实例状态的地方设置为<strong>临界区</strong>，用于实现对临界资源的保护，即确保同一时间内只有一个线程执行处理。使用时应确定<strong>保护对象</strong>、<strong>以什么单位保护</strong>、<strong>使用哪个锁保护</strong></p><blockquote><p>synchronized</p></blockquote><p> <code>char</code> <code>int</code> 等基本类型，以及对象等引用类型的<strong>读写操作</strong>是原子的，而<code>long</code> <code>double</code>在32位JVM上的读写不是原子的, 而在64位JVM上是原子的</p><blockquote><p>JUC-Semaphore</p></blockquote><p>当我们想要确保某个区域“最多只能由N个线程”执行，就需要用<strong>计数信号量</strong>来控制</p><br/><p><strong>课后习题</strong></p><ol><li><p>在<strong>Single Threaded Execution</strong> 模式中，满足下述条件时，死锁便会发生：</p><ul><li>存在多个<code>SharedResource</code>角色</li><li>请求和保持、不可剥夺</li><li>获取<code>SharedResouce</code>角色的锁的顺序不固定（循环等待）</li></ul><p>那么我们破坏任一条件便可防止死锁发生，考虑<strong>哲学家进餐问题</strong>，我们可以有如下的解决思路：</p><ul><li>将筷子<strong>打包</strong>，以包作为竞争单位。</li><li>每个人都按照 筷1 -&gt; 筷2 … 的顺序竞争。</li></ul><p>循环等待的前提便是有多个资源，即条件三的前提是条件一</p></li></ol><br/><h3 id="II-Immutable"><a href="#II-Immutable" class="headerlink" title="II.Immutable"></a>II.Immutable</h3><p>该模式旨在使用<strong>确保实例状态不会发生改变的类</strong>，这样在访问这些实例变量时无须执行互斥处理，故而可以提高性能</p><blockquote><p>何时使用Immutable</p></blockquote><ul><li>实例创建后，状态不再发生改变</li><li>实例是共享的，且被频繁访问</li></ul><blockquote><p>考虑成对的mutable和immutable</p></blockquote><p>为提高性能，将类分为<code>mutable</code>和<code>immutable</code>两种实现；e.g. <code>String</code>和<code>StringBuffer</code></p><br/><h3 id="III-Guarded-Suspension"><a href="#III-Guarded-Suspension" class="headerlink" title="III.Guarded Suspension"></a>III.Guarded Suspension</h3><p>该模式类似于“附加<strong>条件</strong>的<code>synchronized</code>”模式，相当于在<code>Single Threaded Execution</code>模式的基础上引入了<strong>同步机制</strong>：即消费者应该在队列不为空是才能取，生产者在队列不满时才能放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardObject</span>&#123;</span><br><span class="line">    syn <span class="title function_">guardedMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(守护条件) wait();</span><br><span class="line">      目标处理</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    syn <span class="title function_">stateChangedMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      目标处理</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><p><strong>课后习题</strong></p><ol><li><code>wait()</code> 和 <code>notifyAll()</code> 操作的都是<code>this</code>的等待队列，和你<code>GuardObject</code>中的自定义字段（e.g. queue）毫无关系</li><li>在实现<strong>同步机制</strong>时，具有对称性的代码很有可能导致死锁，这个时候我们不妨加入一个<strong>种子</strong>，从而保证代码正常运行&#x2F;正常结束</li></ol><br/><h3 id="IV-Balking"><a href="#IV-Balking" class="headerlink" title="IV.Balking"></a>IV.Balking</h3><p>该模式与<code>Guarded Suspension</code>模式类似，也存在守护条件。但该模式下守护条件不成立时，则<strong>立刻中断返回</strong></p><blockquote><p>使用时机</p></blockquote><ul><li>并不需要执行，因为之前已经执行过了</li><li>若守护条件不成立，想立即返回并进入下一步</li><li>守护条件仅在第一次成立时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">//initialized字段状态仅变化一次，称之为【闭锁】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    syn <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(initialized) <span class="keyword">return</span>;   <span class="comment">//balking</span></span><br><span class="line">      具体处理</span><br><span class="line">      initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>超时 guarded timed</p></blockquote><p>介于<code>Balking</code>和<code>Guarded Suspension</code>，我们选择在守护条件成立之前等待一段时间，如果到时条件还未成立，则直接<code>balk</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timeout;</span><br><span class="line">    </span><br><span class="line">    syn <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//开始时间</span></span><br><span class="line">      <span class="keyword">while</span>(!ready)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">rest</span> <span class="operator">=</span> timeout-(now-start);        <span class="comment">//剩余时间</span></span><br><span class="line">        <span class="keyword">if</span>(rest &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(rest);</span><br><span class="line">      &#125;</span><br><span class="line">      具体处理</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    syn <span class="title function_">setExecutable</span><span class="params">(<span class="type">boolean</span> on)</span>&#123;</span><br><span class="line">      ready = on;</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="V-Producer-Consumer"><a href="#V-Producer-Consumer" class="headerlink" title="V.Producer-Consumer"></a>V.Producer-Consumer</h3><p>生产者-消费者模式，当两者只有一个时，称之为<code>pipe</code>模式。该模式的目的是让<strong>生产者可以安全地将数据交给消费者</strong>，故而引入一个“中间角色“，负责线程协调运行</p><p><strong>重要启示：线程协调运行需要考虑”放在中间的东西“；现场互斥处理需要考虑”应该保护的东西“</strong></p><blockquote><p>InterruptedException</p></blockquote><ul><li><code>sleep</code>、<code>join</code>的线程被中断，立马在该线程中抛出异常</li><li><code>wait</code>的线程被中断，需要在该线程重新获取锁之后才会抛出异常（即在<strong>入口队列</strong>中的线程不会被中断）</li><li><strong><code>interrupt</code>不需要获取线程的锁；<code>notify/notifyAll</code>需要获取线程的锁</strong></li></ul><blockquote><p>JUC-BolckingQueue</p></blockquote><ul><li><code>ArrayBlockingQueue</code> <code>LinkedBlockingQueue</code></li><li><code>PriorityBlockingQueue</code></li><li><code>DelayQueue</code>：在元素指定时间到期后才可以<code>take</code>，到期时间最长的元素先被<code>take</code></li><li><code>SynchronousQueue</code>：用于执行<code>Producer</code>角色到<code>Consumer</code>角色的<strong>直接传递</strong>，即有一方没准备好时，另一方调用接口会被阻塞</li></ul><blockquote><p>JUC-Exchanger</p></blockquote><p>用于让两个线程安全地交换对象</p><br/><p><strong>课后习题：</strong></p><ol><li>如何实现 清除“中间角色”的所维护的数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syn <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">    清除操作...</span><br><span class="line">    notifyAll();    <span class="comment">//清除完要通知所有等待队列上的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><br/><h3 id="VI-Read-Write-Lock"><a href="#VI-Read-Write-Lock" class="headerlink" title="VI.Read-Write Lock"></a>VI.Read-Write Lock</h3><p>读者写者模式，<strong>对不同种类线程的互斥处理分开考虑</strong>：多个线程可以同时读取，读取时不能写入；一个线程写入时，其他线程不能读取或写入</p><p>该模式适用于<strong>读取操作繁重</strong>、<strong>读取频率比写入频率高</strong>时的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLock</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">readingReaders</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">waitingWriters</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">writingWriters</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">preferWriter</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">//防止写线程“饿死”</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="keyword">while</span>(writingWriters &gt; <span class="number">0</span> || (preferWriter &amp;&amp; waitingWriters &gt; <span class="number">0</span>))&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    readingReaders++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">readUnLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    readingReaders--;</span><br><span class="line">    preferWriter = <span class="literal">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    waitingWriters++;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(readingReaders &gt; <span class="number">0</span> || writingWriters &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      waitingWriters--;</span><br><span class="line">    &#125;</span><br><span class="line">    writingWriters++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeUnLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    writingWriters--;</span><br><span class="line">    preferWriter = <span class="literal">false</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JUC-ReadWriteLock</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>主要特征：</p><ul><li><p><strong>公平性</strong></p><p>让等待时间久的线程优先获得锁</p></li><li><p><strong>可重入性</strong></p><p><code>Reader</code>角色的线程可以获得“用于写入的锁”，<code>Writer</code>可获得“用于读取的锁”</p></li><li><p><strong>锁降级</strong></p></li></ul><br/><p><strong>课后习题：</strong></p><ol><li><p><code>waitingWriters</code>和<code>preferWriters</code>字段的含义：</p><p>防止<code>ReaderThread</code>或者<code>WriterThread</code>不会**“饿死”**：<code>waitingWriters &gt; 0</code>可以让<code>ReaderThread</code>线程等待，防止<code>WriterThread</code>饿死；再加上<code>preferWriters</code>控制两类进程哪一类更优先，防止<code>ReaderThread</code>饿死</p></li></ol><br/><h3 id="VII-Thread-Per-Message"><a href="#VII-Thread-Per-Message" class="headerlink" title="VII.Thread-Per-Message"></a>VII.Thread-Per-Message</h3><p>该模式是为每个命令或请求<strong>新分配一个线程</strong>，由这个线程来执行具体处理，实现<strong>调用与执行相分离</strong>。</p><p>目的在于提高程序响应性，是否选用取决于<strong>线程启动耗时</strong>与<strong>具体操作耗时</strong>间的均衡</p><blockquote><p>JUC-Executor</p></blockquote><img src="/Blog/img/6453e32b98ce084a632551d3ff5ac185.jpg" alt="扫描件_Creates interface.jpg" style="zoom:20%;" /><ul><li><code>ThreadFactory</code> 将线程创建抽象化，<code>Executor</code> 将线程执行抽象化</li><li><code>ExecutorService</code> 将<strong>被复用</strong>的线程抽象化（所谓抽象化，就是对外隐藏了实现细节）</li><li><code>cheduleExecutorService</code> 将被调度的线程的执行抽象化</li></ul><p><strong>！课后习题 7-5、7-7</strong></p><br/><h3 id="VIII-Worker-Thread-Thread-Pool"><a href="#VIII-Worker-Thread-Thread-Pool" class="headerlink" title="VIII.Worker Thread&#x2F;Thread Pool"></a>VIII.Worker Thread&#x2F;Thread Pool</h3><p>该模式类似于<code>Thread-Per-Message</code>和<code>Produce-Consumer</code>模式的结合。对于前者，优势在于新线程是事先启动的(存在于<strong>线程池</strong>中)，故而可以<strong>节省线程启动时间</strong>；对于后者，引入的线程池就相当于<code>Consumer</code>角色工作的环境，里面有<code>Channel</code>角色和<code>Consumer</code>角色</p><blockquote><p>Runnable的意义</p></blockquote><p>Runnable对象可以作为方法参数传递，可以放入队列，可以跨越网络传递，也可以被保存至文件中。故而我们可以将其看作<code>Command</code>模式下的<code>Command</code>角色</p><p><strong>!课后习题8-5、8-6</strong></p><br/><h3 id="IX-Future"><a href="#IX-Future" class="headerlink" title="IX.Future"></a>IX.Future</h3><p><code>Thread-Per-Message</code>将耗费时间的处理交给其他线程，可提高响应性。但是在将处理转交出去的时候，处理结果仍然未知，而等待处理结果的话程序响应性会降低</p><p><code>Future</code>意义便在于，可以**在不用降低响应性的前提下获取结果，**做到“准备返回值”和“使用返回值”相分离</p><blockquote><p>Future角色的变种</p></blockquote><ul><li><strong>不让主线程久等</strong>。若<code>RealData</code>的实例还未准备好，主线程调用<code>getContent</code>方法时会进行等待(<code>Guarded Suspension</code>)，我们可以使用<code>Balking</code>，然后稍微执行些其他操作再去调用<code>getContent</code></li><li>**会发生变化。**通常情况下，“返回值”仅会被设置到Future角色中一次，即Future角色的状态只会改变一次。但有时也会有给Future角色设置“当前返回值”的需求，这是我们可以考虑反复设置“返回值”。</li></ul><blockquote><p>JUC-Future（代码见VScode）</p></blockquote><p><img src="/Blog/img/ae6fd5b57d3126d5e5cc12aaa63267f1.png" alt="screen-capture"></p><br/><h3 id="X-Two-Phase-Termination"><a href="#X-Two-Phase-Termination" class="headerlink" title="X.Two-Phase Termination"></a>X.Two-Phase Termination</h3><p>该模式可以做到”优雅地结束线程”，其要点在于：安全地终止线程**（安全性）<strong>、必定进行终止处理</strong>（生存性）<strong>、发出终止请求后尽快执行终止处理</strong>（响应性）**</p><blockquote><p>终止处理</p></blockquote><ul><li><p>未捕获的异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable e)</span>&#123;</span><br><span class="line">      <span class="comment">//执行未捕获异常的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>退出钩子</p><p><strong>指java虚拟机退出时启动的线程，使用其来编写程序完全终止时的终止处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//终止处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>JUC-CountDownLatch</p></blockquote><p>实现”等待<strong>指定次数</strong>的<code>CountDown</code>方法被调用”这一功能</p><blockquote><p>JUC-CyclicBarrier</p></blockquote><p><code>CountDownLatch</code>只能进行倒数计数，而<code>CyclicBarrier</code>可以<strong>周期性</strong>的创建屏障，碰到屏障的线程是无法继续前进的。屏障的解除条件是**到达屏障处的线程个数达到了指定个数，**这样屏障解除，这簇线程便会一起“冲出去”</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023这一年</title>
      <link href="/Blog/2023/12/28/2023-zhe-yi-nian/"/>
      <url>/Blog/2023/12/28/2023-zhe-yi-nian/</url>
      
        <content type="html"><![CDATA[<p>西安入冬后的第一场雪，正好落在了我的行李箱上。</p><p>写下这篇随笔的时候，我已经和7&#x2F;8的大学生活拜拜了，感觉时间果然还是以人不可预知的速度流逝着。本来计划按着别人博客的样子，分模块做个年度总结啥的，想了想也甭费那工夫了，简单扯扯吧。</p><span id="more"></span><p>年初看2023，是水到渠成的话，现在看2023就是苦尽甘来了。新春伊始，年味正浓着，人便躺家里了：过敏，还是激素过敏，激素还是抗过敏激素。</p><p>突然想到高中还背过过敏反应：发作迅速、反应强烈、消退较快。那就快折腾了我俩月，清明才去的学校(当然彻底好全那是暑假前了)。严重那会，天天感觉自己在忍受着什么极大的苦难，现在来看还挺有意思的：像我这样的人，总是在遭受病痛的同时，夸大其威力，可这恰恰不是悲观，反而是因为有信心能挺过苦痛，等一切结束了，便会想：这么糟糕的事情我都挺过去了，还真了不起。</p><p>迷迷糊糊地去了学校，打了两场蓝桥杯，参加了大学生计算机设计大赛，收拾收拾就放暑假了。</p><p>假期也是全部献给了考研复习：数一英一，专业课。从没想过参加夏令营，虽然我也在保研边缘，但是是边缘之外，于是暑假也就变短了些。</p><p>再回学校，辈分已经是最大的那一届。没想太多便又投入到备考中去，顺便拿了一个南理工的预推免名额。后来得知，原来今年本专业的外保名额，自己是占一个的，高兴是真高兴，庆幸也是真庆幸：还好参加了南理的与推免。</p><p>放下身上的担子，终于可以看看前方的景色了；过去因考研放下的兴趣，也可以拾起来了。但却并不觉得轻松。</p><p>我不知道读了研究生以后，还能不能再遇到这么一个欢快的宿舍</p><p>不知道看着身边的朋友分分合合，自己也能不能出息一点</p><p>不知道走出象牙塔之后，自己会变成什么样子……</p><p>不是什么样子罢，从大一开始的没能参加社团，到现在的只会敲点代码慰藉人生，我想应该做出点改变了。</p><p>2024，爷来也！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术I (Version.12)</title>
      <link href="/Blog/2023/10/07/java-he-xin-ji-zhu/"/>
      <url>/Blog/2023/10/07/java-he-xin-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h3 id="IV-对象与类"><a href="#IV-对象与类" class="headerlink" title="IV. 对象与类"></a>IV. 对象与类</h3><ol><li><p><strong>记录</strong></p><p>记录是一种特殊形式的类，其状态不可变，而且公共可读。如果需要完全由一组变量表示不可变数据，那么应该使用记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例字段x、y称为组件</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line">  <span class="comment">//这是自定义构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span> &#123;<span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>)&#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//【自动定义地】设置所有实例字段的构造器称为标准构造器</span></span><br><span class="line">  <span class="comment">//标准构造器也可以被提供</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还有简洁形式，但简洁形式的主体是标准构造器的“前奏”</span></span><br><span class="line">  <span class="comment">//它只是在为实例字段赋值前修改参数变量x、y</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  public Point&#123;</span></span><br><span class="line"><span class="comment">  *     if(x &gt; y) y += x;</span></span><br><span class="line"><span class="comment">  *  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><br/><h3 id="V-继承"><a href="#V-继承" class="headerlink" title="V.继承"></a>V.继承</h3><ol><li><p><strong>完美equals编写</strong></p><ol><li>将显式参数命名为otherObject， 稍后需要将它强转为other</li><li>检测 this 与 otherObject 是否相同（这句只是一个小优化）</li><li>检测 other0bject 是否为null, 如果为 null, 则返回 false</li><li>比较 this 与 otherObject 的类。如果 <strong>equals的语义可以在子类中改变</strong>, 就使用<code>getClass</code>检测；如果<strong>所有的子类都有相同的相等性语义</strong>，则可以使用<code>instanceof</code>检测</li><li>现在根据相等性概念的要求来比较字段。使用<code>==</code>比较基本类型字段，使用<code>Objects.equals()</code> 比较对象字段。如果所有的字段都匹配, 就返回 true。子类如果重新定义了<code>equals</code>，就要包含一个<code>super.equal(other)</code>调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* equals 子类语义有改变</span></span><br><span class="line"><span class="comment">    * if(getClass() != otherObject.getClass()) return false;</span></span><br><span class="line"><span class="comment">    * ClassName other = (ClassName) otherObject;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* equals 子类语义均一致</span></span><br><span class="line"><span class="comment">    * if(!(otherObject instanceof ClassName other)) return false;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> filed1 == other.filed1</span><br><span class="line">      &amp;&amp; Object.equals(filed2, other.filed2)</span><br><span class="line">      &amp;&amp;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>super</code>不是一个对象的引用，只是一个指示编译器调用超类方法的特殊关键字</p></li><li><p>重写的方法，方法签名（指一个<strong>方法的名称和参数列表</strong>）必须一样，而返回类型只需要<strong>更严格</strong>就行（称为有<strong>协变</strong>的返回类型），方法可见性需要更宽松。</p></li><li><p><code>protected</code>类型，同包和子类可访问。但是考虑下面这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fa</span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Fa</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Son2在另一个包中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Fa</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ok</span></span><br><span class="line">    fun()</span><br><span class="line">    <span class="comment">//error: The method fun() from the type Fa is not visible</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Son1</span>().fun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原因就在于，Son1中的fun方法是从Fa中继承的，【其可见性是对于Son1而言的】</span></span><br><span class="line"><span class="comment">//只对Son1同包或者Son1的子类可见，Son2中自然不可见</span></span><br></pre></td></tr></table></figure></li></ol><br/><h3 id="VI-接口、lambda与内部类"><a href="#VI-接口、lambda与内部类" class="headerlink" title="VI. 接口、lambda与内部类"></a>VI. 接口、lambda与内部类</h3><ol><li><p>对于<strong>匿名类</strong>，以下测试会失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//equals</span></span><br><span class="line"><span class="keyword">if</span>(getClass() != other.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每个匿名类类型：外部类类名$1、外部类类名$2、...</span></span><br></pre></td></tr></table></figure></li><li><p>如何在静态方法中获取调用静态方法的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getClass();    <span class="comment">//Error, 静态方法中没有this</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Object</span>()&#123;&#125;.getClass.getEnclosingClass()   <span class="comment">//Success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java9后，接口中的方法可以是<code>private</code>，但只能用做其他方法的辅助</p></li><li><p>Object中定义了<code>protected Object clone()&#123;...&#125;</code>，如果任何类想要实现克隆自己，那么应该在类中重写这个方法<code>public ClassName clone()&#123;...&#125;</code>（记得<code>Cloneable</code>）。如此一来，在其他类中便可以调用这个类的<code>clone</code>方法获取其克隆对象，否则调用<code>clone</code>是不可见的，详见 V.4</p></li></ol><br/><h3 id="VII-异常、断言和日志"><a href="#VII-异常、断言和日志" class="headerlink" title="VII.异常、断言和日志"></a>VII.异常、断言和日志</h3><ol><li><p>一个方法必须声明所有可能抛出的<strong>检查型异常</strong>，而<strong>非检查型异常</strong>要么在你的控制之外(Error，jvm层面的错误)，要么从一开始就应该避免（RuntimeException）</p></li><li><p>异常使用技巧：</p><ol><li><strong>早抛出，晚捕获</strong>。例如，当栈为空时，<code>Stack.pop</code>是该返回<code>null</code>，还是抛出一个异常？著者认为是后者，因为这要好于以后出现一个<code>NullPointerException</code>异常</li><li><strong>使用标准化方式报告异常</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Objects::</span><br><span class="line">  requireNonNull</span><br><span class="line">  checkIndex</span><br><span class="line">  checkFromIndex</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>断言失败</strong>是致命的、不可恢复的错误；不要捕获断言异常，断言是用来测试而不是从中恢复，只适用于测试和开发环境；</p><p>私认为，可以类比于用<code>printf</code>进行调式</p></li></ol><br/><h3 id="VIII-泛型程序设计"><a href="#VIII-泛型程序设计" class="headerlink" title="VIII.泛型程序设计"></a>VIII.泛型程序设计</h3><ol><li><p><strong>PESC原则：</strong>（将泛型容器看作P或者C）</p><ol><li>频繁往外读取内容的，适合用上界<code>Extends</code></li><li>经常往里插入的，适合用下界<code>Super</code></li></ol><p>为何会出现<strong>通配符类型：<strong>假定有<code>Fruit</code>类和<code>Apple</code>类，二者有继承关系，然后有一个简单的泛型容器<code>Plate&lt;T&gt;</code>，代表装…的盘子。问题来了：<code>Plate&lt;Fruit&gt;</code>和<code>Plate&lt;Apple&gt;</code>没有任何继承关系</strong>（即泛型没有协变性）</strong>， 所以下述语句虽然逻辑上有理，但Java编译器不通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p= <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br></pre></td></tr></table></figure><p>为了让泛型容器之间产生联系，便有了上界通配符<code>&lt;? extends T&gt;</code>和下界通配符<code>&lt;? super T&gt;</code>，举个例子，<code>&lt;? extends Fruit&gt;</code>的子类型有<code>&lt;Apple&gt;、&lt;Orange&gt;…</code>， <code>&lt;? super Apple&gt;</code>的子类型有<code>&lt;Fruit&gt;、&lt;Object&gt;…</code></p></li><li><p><strong>虚拟机中的泛型擦除</strong>：</p><ol><li><p>虚拟机中没有泛型，只有普通的类和方法</p></li><li><p>所有类型参数都会替换为它们的<strong>限定类型</strong><code>(e.g. T -&gt; Object, U extends Comparable&amp;Runnable -&gt; Comparable，必要时添加Runnable强转)</code></p></li><li><p>会<strong>合成桥方法</strong>来保持多态</p><p>在Java代码中，方法名称和参数类型指定一个方法；而在<strong>虚拟机</strong>中，<strong>方法名称</strong>、<strong>参数类型</strong>和<strong>返回值</strong>共同指定一个方法。故而桥方法可以合理存在；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(T args1)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;LocalDate&gt;&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(LocalDate args1)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上述代码目的是重写fun，但类型擦除后B中会有这俩fun</span></span><br><span class="line"><span class="comment">* public void fun(Object args1)</span></span><br><span class="line"><span class="comment">* public void fun(LoaclDate args1)</span></span><br><span class="line"><span class="comment">* 两个方法显然不一样，但逻辑上应该一样，从而保证多态</span></span><br><span class="line"><span class="comment">* 因此编译器在B中合成一个桥方法，这才是真正重写fun的方法</span></span><br><span class="line"><span class="comment">* public void fun(Object args1)&#123;fun((LoaclDate)args1)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桥方法不只用于泛型类型，还出现在方法重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*实际上，Employee有俩clone方法：</span></span><br><span class="line"><span class="comment">* Employee clone()    自己定义的</span></span><br><span class="line"><span class="comment">* Object clone()      合成的桥方法，覆盖了Object.clone</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>为保持类型安全性，必要时会插入强制类型转换</p></li></ol></li></ol><br/><h3 id="IX-集合"><a href="#IX-集合" class="headerlink" title="IX.集合"></a>IX.集合</h3><ol><li><p><code>Iterator</code>迭代器，不要想着迭代器指向某个元素，而应该认为迭代器位于两个元素中间，当调用<code>next</code>时，迭代器就会<strong>越过</strong>下一个元素，并返回刚刚越过的那个元素</p><img src="/Blog/img/d5605913432ca6c83ef602e065f2ed64.jpg" alt="iterator.jpg" style="zoom:10%;" /></li><li><p>在迭代过程中，如果集合被其他线程修改，迭代失效，抛出<code>ConcurrentModificationException</code>异常；但<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>除外，<strong>写时拷贝数组</strong>的迭代器在迭代过程中，即使数组被修改仍然可以正常访问（但可能过时）视图。</p><br/></li></ol><h3 id="XII-并发"><a href="#XII-并发" class="headerlink" title="XII.并发"></a>XII.并发</h3><ol><li><p>java线程有6种状态：<code>New</code> <code>Runnable</code> <code>Blocked</code> <code>Waiting</code> <code>Timed waiting</code> <code>Terminated</code></p><img src="/Blog/img/a2ee154e13f7cb642148cfc548521932.jpg" alt="thread.jpg" style="zoom:10%;" /></li><li><p>除了已经废弃的<code>stop</code>方法，没有办法强制一个线程终止，但可以用<code>interrupted</code>来请求终止一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞和中断相遇，会抛出InterruptedException</span></span><br><span class="line">实例方法isInterrupted 调用后不会改变中断状态 </span><br><span class="line">静态方法interrupted 调用后会清除【当前执行线程】的中断状态</span><br></pre></td></tr></table></figure></li><li><p>同步操作：</p><ol><li><p><strong>Lock&#x2F;Condition</strong></p></li><li><p><strong>synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于使用该对象的内部锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而wait、notifyAll/notify等同于使用内部锁关联的条件对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个对象的锁来实现额外的原子操作，称为客户端锁定</span></span><br><span class="line"><span class="comment">//但这样完全依赖于：Vector类会对自己的所有更改器方法使用内部锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Vector&lt;Integer&gt; vInt, ...)</span>&#123;</span><br><span class="line">    <span class="comment">//同步块</span></span><br><span class="line">    synchronsized(vInt)&#123;</span><br><span class="line">        vInt.set(...);</span><br><span class="line">        vInt.set(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>volatile字段</strong></p><p>适用于共享变量只存在<strong>赋值操作</strong>，不会进行其他操作</p></li><li><p><strong>线程安全的集合</strong></p><p>阻塞队列、并发散列映射、并发集、写时拷贝数组、使用同步包装器</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
