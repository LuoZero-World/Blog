<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><style type="text/css">.douban-card-block {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    max-height: 400px;
}

.douban-card {
    display: flex;
    margin: 30px 10px;
    padding: 15px;
    border-radius: 15px;
    position: relative;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    color: antiquewhite;
    text-decoration: none;
}

.douban-card:hover {
    text-decoration: none;
}

.douban-card-bgimg {
    position: absolute;
    width: 115%;
    height: 115%;
    filter: blur(15px) brightness(0.6);
    background-size: 100%;
    background-position: center;
    background-repeat: no-repeat;
}

.douban-card-img {
    position: relative;
    height: 130px;
    width: 80px;
    background-size: 100%;
    background-position: center;
    background-repeat: no-repeat;
}

.douban-card-left:hover .douban-card-img {
    filter: blur(5px) brightness(0.6);
    transform: perspective(800px) rotateX(180deg);
}

.douban-card-left .douban-card-img {
    transition: all 500ms ease;
}

.douban-card-left {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.douban-card-left .douban-card-status {
    height: 130px;
    width: 80px;
    text-align: center;
    font-weight: bold;
    position: absolute;
    left: 0;
    top: 30%;
    transform: rotateX(180deg);
    backface-visibility: hidden;
    transition: all 500ms ease;
}

.douban-card-left:hover .douban-card-status {
    transform: perspective(800px) rotateX(0deg);
}

.douban-card-right {
    position: relative;
    display: flex;
    flex-direction: column;
    margin-left: 12px;
    font-size: 16px;
    font-family: "Courier New", Courier, monospace;
    line-height: 1.3;
    color: antiquewhite;
}

.douban-card-item {
    margin-top: 4px;
}
</style><!-- hexo injector head_begin end --><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="编程路上的随笔"><title>算法模板 | LuoZero's World</title><link rel="preload" href="/Blog/CangEr.woff2" as="font" type="font/woff2" crossorigin><style>@font-face {
  font-family: "Cang Er";
  src: url('/Blog/CangEr.woff2') format('woff2');
}
</style><link rel="stylesheet" type="text/css" href="/Blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/Blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/Blog/favicon.ico"><link rel="apple-touch-icon" href="/Blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/Blog/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/Blog/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/Blog/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法模板</h1><a id="logo" href="/Blog/.">LuoZero's World</a><p class="description">和光同尘,与时舒卷</p></div><div id="nav-menu"><a class="current" href="/Blog/."><i class="fa fa-home"> 首页</i></a><a href="/Blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/Blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">算法模板</h1><div class="post-meta">2025-02-23<span> | </span><span class="category"><a href="/Blog/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 8.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 40</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/Blog/2025/02/23/suan-fa-mo-ban/#waline"><span class="waline-comment-count" id="/Blog/2025/02/23/suan-fa-mo-ban/"></span><span> 条评论</span></a><div class="post-content"><h2><span id></span></h2><h3><span id="回溯算法">回溯算法</span></h3><p><strong>感悟：<strong>回溯必须有终止条件，最好为</strong>边界判断</strong>和其他一些逻辑判断（即判断不符合要求的情况），这会很方便后面回溯的进行；当然，回溯前也可以进行判断，以免进行不必要的回溯。</p>
<p><strong>找子集：</strong> 从当前idx开始添加+isV；<strong>全排列：</strong> 从0开始添加+isV；当有重时，记住：若isV中上一个已经搜索完其子递归树，且这一个和上一个值相等，那么这一个没有继续递归的必要。p.s.全排列还可以通过交换的方式获得，但这时不好去重</p>
<blockquote>
<p>Minimax 算法中的 Alpha-Beta 剪枝</p>
</blockquote>
<p>利用搜索树每个节点取值的上下界来进行剪枝优化，注意点：</p>
<ol>
<li>每个节点具有<strong>最大下界</strong>和<strong>最小上界</strong>，且每个节点向上层节点返回自己的计算结果</li>
<li>上层节点以自己的上下界来<strong>初始化</strong>下层节点的上下界，最初以±∞表示</li>
<li>Min节点改变上界(Beta)，Max节点改变下界(Alpha)</li>
<li>一旦某节点<strong>上下界矛盾</strong>，进行剪枝</li>
</ol>
<hr>
<h3><span id="并查集">并查集</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启了路径压缩和按秩合并的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">// 当前连通分支数目</span></span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无秩 并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3><span id="树状数组">树状数组</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点tree[x]覆盖的长度为lowbit(x),其父节点为tree[x+lowbit(x)]</span></span><br><span class="line"><span class="comment">// 上来先把三个方法写出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">binIndexedTree</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化「树状数组」，要默认数组是从 1 开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">binIndexedTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">      tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询前缀和的方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在树状数组 x 位置中增加值 u</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tree.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：<strong>树状数组动态维护</strong>前缀和</strong>，可单点修改，单点查询，区间查询；<strong>区间修改什么的，还是用线段树吧（若只有区间修改可以差分+树状）</strong></p>
<hr>
<h3><span id="二分查找">二分查找</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//acwing 789</span></span><br><span class="line"><span class="comment">//找一个数在数组中的起始与结束位置</span></span><br><span class="line"><span class="type">int</span>[] binSearch(<span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//找起始位置</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; num) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">0</span>] = arr[l] == num ? l : -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找末位置</span></span><br><span class="line">    l = <span class="number">0</span>; r = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; num) r = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">1</span>] = arr[l] == num ? l : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：<strong>二分查找，<strong>先确定查找的参数</strong>是哪一个，确定两个区间，再确定使用二分产生的开销能否接受（往往与O(n)遍历结合）；&#x3D;&#x3D;二分查找的</strong>本质</strong>是查找<strong>具有二段性</strong>的区间的端点 &#x3D;&#x3D;，因此有两个模板，按需使用</p>
<p><strong>浮点数二分，</strong> 由于每次<code>mid</code>不会和<code>l、r</code>重复，因此不用担心无限循环问题，<code>while</code>判断条件往往为<code>l-r &lt;= 1e-m</code>，<code>m</code>根据经验，一般为所需精度减2</p>
<hr>
<h3><span id="manachar">Manachar</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">//构造马拉车字符串</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">preProcess</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;^$&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">&quot;#&quot;</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">T</span> <span class="operator">=</span> preProcess(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> T.length(), res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//马拉车字符串各字母的回文半径</span></span><br><span class="line">    <span class="type">int</span>[] P = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i_mirror</span> <span class="operator">=</span> <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res统计所有的回文子串</span></span><br><span class="line">        res += P[i]/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：</strong> Manachar算法前置须知：马拉车字符串的回文半径&#x3D;原字符串中对应回文串长度  从马拉车字符串的C位置推得原串中起始位置：start&#x3D;(Cindex-P[C])&#x2F;2;</p>
<p>然后就可以通过遍历依次求出对应字母的回文半径，需要动态维护<strong>最长右界R和最长右界的中心C，<strong>然后根据</strong>回文串内</strong>的对称性推当前字母回文半径。</p>
<h3><span id="kmp">KMP</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串s 模式串p 均从下标1开始</span></span><br><span class="line"><span class="type">char</span>[] s, p;</span><br><span class="line"><span class="type">int</span>[] next;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">//重点在于，比较的是下一个字符！所以j+1,而i已经表示下一个字符</span></span><br><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">        <span class="comment">//匹配成功一次</span></span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3><span id="单调栈">单调栈</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左侧最近 严格小于 位置</span></span><br><span class="line"><span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//从左往右</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.isEmpty() &amp;&amp; left[st.peek()] &gt;= left[i]) st.pop();</span><br><span class="line">    <span class="comment">//通常存储索引</span></span><br><span class="line">    left[i] = st.isEmpty() ? -<span class="number">1</span> : st.peek();</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="单调队列">单调队列</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典用例: 滑动区间求最值</span></span><br><span class="line"><span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果一次进入一个元素，第一句的while可换成if</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;   <span class="comment">//队尾元素出队列</span></span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ps.单调队列在上面的dp多重背包问题中应用*/</span></span><br></pre></td></tr></table></figure>

<p><strong>感悟：<strong>单调队列和单调栈中的元素，顾名思义都是单调的，因此可以在其中进行</strong>二分</strong>、<strong>求极值</strong>等操作。</p>
<hr>
<h3><span id="时间戳">时间戳</span></h3><p>用处：<strong>判断树中一个节点是否是另外一个节点的祖先节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录dfs一棵树时,每个节点的进入时间和退出时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="type">int</span>[] in, out;</span><br><span class="line">    <span class="type">int</span> clock;</span><br><span class="line">    <span class="comment">//leetcode 2322为例子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">        <span class="comment">//根据edges建树</span></span><br><span class="line">        Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">            g[x].add(y);</span><br><span class="line">            g[y].add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入时间</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//退出时间</span></span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入当前遍历到的节点x,和其父节点y</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">        in[x] = ++clock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y : g[x])&#123;</span><br><span class="line">            <span class="comment">//y需要是x的子节点</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        out[x] = clock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断n1是否是n2的祖先节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isParent</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(in[n1] &lt; in[n2] &amp;&amp; out[n2] &lt;= out[n1]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：<strong>dfs遍历时每个节点只会遍历一次，根据</strong>父子关系</strong>避免了遍历以及遍历过的节点；当然我们也可以设置 isVisited[] 来避免</p>
<hr>
<h3><span id="跳表">跳表</span></h3><ol>
<li>跳表是可以实现二分查找的有序链表</li>
<li>每个元素插入时随机生成它的level <strong>（索引层数，最底层为1）</strong></li>
<li>最底层包含所有的元素</li>
<li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li>
</ol>
<hr>
<h3><span id="二维差分">二维差分</span></h3><p>一维差分数组求原数组，通过前缀和得到；二维自然也是求二维前缀和：即从矩阵左上角开始算起，到当前位置所围成小差分矩阵内的数字和。</p>
<p>区域改变时的规则：</p>
<img src="/Blog/img/0fe56b8bd48550b327275f6d9cdf35e7.jpg" alt="微信图片_20230313103218.jpg" style="zoom:50%;">

<hr>
<h3><span id="离散化">离散化</span></h3><p>将题目中所有给出的数字，<strong>排序去重</strong>，再映射到<code>1 ~ n</code>的区间中，因此需要借助<strong>二分查找</strong>得到区间位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unique</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> waitTodc.size(), res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(waitTodc.get(i) != waitTodc.get(i-<span class="number">1</span>)) &#123;</span><br><span class="line">          waitTodc.set(res, waitTodc.get(i));</span><br><span class="line">          res++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找映射后的区间位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= waitTodc.get(mid)) r = mid;</span><br><span class="line">      <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2><span id="数学">数学</span></h2><h3><span id="埃氏筛法">埃氏筛法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛除每个质数的倍数 O(nlog(logn))</span></span><br><span class="line"><span class="comment">//n*(1/1+1/2+...1/n)</span></span><br><span class="line"><span class="type">int</span>[] primes;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">boolean</span>[] st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">      primes[cnt++] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="线性筛法">线性筛法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据每个数的最小质因子，筛除每个合数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; primes[j] &lt;= n/i; j++)&#123;</span><br><span class="line">      <span class="comment">//primes[j] 一定是 primes[j]*i 的最小质因子</span></span><br><span class="line">      st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">//去掉这句就是埃氏筛法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="欧拉函数">欧拉函数</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示1~n中和n互质的数的个数</span></span><br><span class="line"><span class="comment">//n*(1-1/p1)*(1-1/p2)*...(1-1/pm) ,p1、...pm均为质因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phi</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);  <span class="comment">//(i-1)/i * res</span></span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//因为for循环退出后只遍历了比sqrt(x)小的质因数，因此还可能留下一个质因数</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可通过线性筛法求欧拉函数，这里不再列举</strong></p>
<p><strong>欧拉定理：</strong> $a^{phi(n)} &#x3D; 1 (modn)$，其中<code>a、n</code>互质</p>
<p><strong>费马定理：</strong>$a^{n-1}&#x3D;1(modn)$，欧拉定理的基础上，<code>n</code><strong>又是质数</strong></p>
<h3><span id="快速幂">快速幂</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质就是将待求数a^n拆成a^1*a^2*...*a^(2^logn)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">qmi</span><span class="params">(<span class="type">long</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">      <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>((b&amp;<span class="number">1</span>) == <span class="number">1</span>) res = res*a%p;</span><br><span class="line">          a = a*a%p;</span><br><span class="line">          b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res%p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="中国剩余定理">中国剩余定理</span></h3><p><em>前置知识：</em></p>
<ol>
<li><p>&#x3D;&#x3D;乘法逆元&#x3D;&#x3D;        <img src="/Blog/img/010e58fd12336484c1f9c64e155e4db2.png" alt="screen-capture" style="zoom:50%;"></p>
<p>当<code>n</code>为质数时，根据<strong>费马定理</strong>，可知$a^{n-2}$即为<code>a</code>的乘法逆元，便不需扩展欧几里得</p>
</li>
<li><p>&#x3D;&#x3D;扩展的欧几里得算法&#x3D;&#x3D;</p>
<ol>
<li><p>最大公约数表示定理（<strong>裴蜀定理</strong>）</p>
<p><img src="/Blog/img/7dca99e400eabad2c0ab33d8f611ce1b.png" alt="screen-capture"></p>
</li>
<li><p>扩展欧几里得算法</p>
<p>在执行欧几里得算法时，利用每一步计算的余数和商，迭代的计算每一步的<code>s</code>和<code>t</code>，最后求出$s_n、t_n$</p>
<p><strong>用之求乘法逆元</strong>    <img src="/Blog/img/f33f00e05f3daca129317f39dc85b606.png" alt="screen-capture" style="zoom:50%;"></p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中国剩余定理</span></span><br><span class="line"><span class="comment">//m1, m2, ..., m_n 两两互质，则下述同余方程组必有唯一解集</span></span><br><span class="line"><span class="comment">//如果存在不互质的m_j，则无需理会那一个同余方程</span></span><br><span class="line"><span class="comment">//              x≡a1( mod m1)</span></span><br><span class="line"><span class="comment">//              x≡a2( mod m2)</span></span><br><span class="line"><span class="comment">//              ...</span></span><br><span class="line"><span class="comment">//              x≡a_n( mod m_n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRT</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>[] mod, remainder;</span><br><span class="line">  <span class="type">long</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//M = sum(m1, m2, ..., m_n)</span></span><br><span class="line">  <span class="comment">//remainder = [a1, a2, ..., a_n]</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CRT</span><span class="params">(<span class="type">int</span>[] mod, <span class="type">int</span>[] remainder)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.mod = mod;</span><br><span class="line">    <span class="built_in">this</span>.remainder = remainder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m : mod) M *= m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//求 (mod m)下的解，易知该解唯一</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">solute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mod.length;</span><br><span class="line">    <span class="type">long</span>[] mod_k = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) mod_k[i] = M/mod[i];</span><br><span class="line">    <span class="comment">//求mod_k中各元素 逆元</span></span><br><span class="line">    <span class="type">long</span>[] inverseE = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) inverseE[i] = (exgcd(mod_k[i], mod[i]))[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      res += (remainder[i]*mod_k[i]*inverseE[i]) ;</span><br><span class="line">      res %= M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回 [0] [1], 使得a*[0]+b*[1] = gcd(a, b)</span></span><br><span class="line">  <span class="type">long</span>[] exgcd(<span class="type">long</span> a, <span class="type">long</span> b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0L</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">long</span>[] res = exgcd(b, a%b);</span><br><span class="line">    <span class="comment">//b*[0] + (a-(a/b)*b)*[1] = gcd(a, b)</span></span><br><span class="line">    <span class="comment">//a*[1] + b*([0]-(a/b)*[1]) = gcd(a, b)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;res[<span class="number">1</span>], res[<span class="number">0</span>] - a/b*res[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="求组合数">求组合数</span></h3><ol>
<li><strong>递推：</strong>$C_a^b&#x3D;C_{a-1}^b+C_{a-1}^{b-1}$，<code>O(n^2)</code></li>
<li>**预处理：**求出所有阶乘，以及所有阶乘的逆元（模p），<code>O(nlogn)</code></li>
<li><strong>卢卡斯定理：</strong>$C_a^b&#x3D;C_{a%p}^{b%p}*C_{a&#x2F;p}^{b&#x2F;p}$， <code>O(logp[n]*p)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">lucas</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> C(a, b);</span><br><span class="line">  <span class="keyword">return</span> C(a%p, b%p) * lucas(a/p, b/p) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>质数相乘：<strong>用于在</strong>不取模</strong>的情况下求解高精度答案</li>
</ol>
<h2><span id="动态规划">动态规划</span></h2><ul>
<li><p>前置思考：设置状态（<strong>变量越多，维度越高；根据最后一步推测</strong>）；有无<strong>后效性</strong>（即某一特定状态转移时，是否受前置状态的条件约束）；边界判断、初始化</p>
</li>
<li><p>线性动态规划 </p>
<p><strong>子序列（不一定连续）：dp[i]表示考虑前i个元素…</strong></p>
<p><strong>子串、子数组（连续）：dp[i]表示以第i个元素结尾…</strong></p>
<p><strong>有正负、上升下降等：0，1区分，进行转移</strong></p>
<p>目前发现特例 <em>最长上升子序列</em></p>
</li>
<li><p><strong>闫氏DP分析</strong></p>
<p><img src="/Blog/img/91996e0c978552cd355532b2369211f5.jpg" alt="4B8264F9FC5BA563A2B3B5A16981A353.jpg"></p>
</li>
<li><p><strong>时间复杂度：</strong> 状态个数 * 转移个数</p>
</li>
</ul>
<br>

<h3><span id="背包问题">背包问题</span></h3><p>常用$dp[i][j]$表示<strong>前i个物品在容量不超j</strong>的情况下的最大价值</p>
<ol>
<li><p><strong>01背包</strong></p>
<p>强调<strong>每件物品只能选择一次</strong>，一维空间优化时<strong>从大到小</strong>遍历</p>
</li>
<li><p><strong>完全背包</strong></p>
<p>强调<strong>每件物品可以无限选择</strong></p>
<p>一维空间优化时，通过换元可达到降低时间复杂度的效果，但要<strong>从小到大</strong>遍历</p>
</li>
<li><p><strong>多重背包</strong></p>
<p>强调<strong>每件物品只能选有限次</strong></p>
<p> 一维空间优化有：</p>
</li>
<li><p>二进制优化 (退化为01背包)、</p>
<p><strong>e.g. 容量1价值1 有7个 -&gt; 容量1价值1+容量2价值2+容量4价值4</strong></p>
</li>
<li><p><strong>单调队列</strong>优化 按余数从小到大遍历</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调队列维护</span></span><br><span class="line"><span class="comment">//控制队列大小-&gt;根据队列维护的最值来进行操作 e.g. dp -&gt;更新队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">//数量s,体积v,价值w</span></span><br><span class="line">  <span class="comment">//有N个物品,求在C的空间内的最大价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> C, <span class="type">int</span>[] s, <span class="type">int</span>[] v, <span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>]; <span class="comment">// 记录上一次的结果</span></span><br><span class="line">        <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[C + <span class="number">1</span>]; <span class="comment">// 优先队列，动态维护 潜力从大到小的!容量!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> v[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">wi</span> <span class="operator">=</span> w[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> s[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上次算的结果存入辅助数组中</span></span><br><span class="line">            g = dp.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 枚举余数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vi; j++) &#123;</span><br><span class="line">                <span class="comment">// 初始化队列，head 和 tail 分别指向队列头部和尾部</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>, tail = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 枚举同一余数情况下，有多少种方案。</span></span><br><span class="line">                <span class="comment">// 例如余数为 1 的情况下有：1、vi + 1、2 * vi + 1、3 * vi + 1 ...</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt;= C; k+=vi) &#123;</span><br><span class="line">                    dp[k] = g[k];</span><br><span class="line">                    <span class="comment">// 将不在窗口范围内的值弹出</span></span><br><span class="line">                    <span class="keyword">if</span> (head &lt;= tail &amp;&amp; q[head] &lt; k - si * vi) head++;</span><br><span class="line">                    <span class="comment">// 如果队列中存在元素，直接使用队头来更新</span></span><br><span class="line">                    <span class="keyword">if</span> (head &lt;= tail) dp[k] = Math.max(dp[k], g[q[head]] + (k - q[head]) / vi * wi);</span><br><span class="line">                    <span class="comment">// 当前值比对尾值更优，队尾元素没有存在必要，队尾出队</span></span><br><span class="line">                    <span class="comment">// 用减法 表明两者都是从dp[k]转移而来</span></span><br><span class="line">                    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / vi * wi &lt;= g[k] - (k - j) / vi * wi) tail--;</span><br><span class="line">                    <span class="comment">// 将新下标入队 </span></span><br><span class="line">                    q[++tail] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[C];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>分组背包</strong></p>
<p>强调<strong>每组物品中只能选一个物品</strong>，因此以当前这一组物品中选哪个物品作为划分子集的依据，进行状态转移</p>
</li>
</ol>
<br>

<h3><span id="数字三角形dp">数字三角形dp</span></h3><p>二维数组，左上到右下，求路径最大值</p>
<p><strong>现在扩展到两条路径，但一个方格的数只能取一次，求路径最大值</strong></p>
<p>状态设置<code>f[i1, j1, i2, j2]</code>，代表两条路径当前停留的位置，每条路径可从上、左两方向转移，因此<strong>两条路径下</strong>有<strong>四种</strong>转移状态。</p>
<p>如何解决所走方格会不会重复？当<code>i1+j1=i2+j2</code>成立时，两条路径的当前停留位置<strong>可能</strong>重复。因此我们可以认为这两条路径<strong>同时</strong>从左上出发，步频一致，那么状态可简化为<code>f[k, i1, i2]</code>，其中<code>k=i1+j1</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= <span class="number">2</span>*n; k++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt;= n; i1++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>; i2 &lt;= n; i2++)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> k-i1, j2 = k-i2;</span><br><span class="line">        <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> w[i1][k-i1];</span><br><span class="line">          <span class="comment">//不重复</span></span><br><span class="line">          <span class="keyword">if</span>(i1 != i2) t += w[i2][k-i2];</span><br><span class="line">          <span class="comment">//下 下</span></span><br><span class="line">          f[k][i1][i2] = f[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2-<span class="number">1</span>]+t;</span><br><span class="line">          <span class="comment">//下 左</span></span><br><span class="line">          f[k][i1][i2] = Math.max(f[k][i1][i2], f[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2]+t);</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">2</span>*n][n][n];</span><br></pre></td></tr></table></figure>

<br>

<h3><span id="状压dp">状压dp</span></h3><p>**tip：**当结果需要多个统计<code>f[][]</code>的值时，不妨让<code>f</code>的第一个维度<code>+1</code>，然后结果直接可以是<code>f[n+1][]</code></p>
<br>

<h3><span id="区间dp">区间dp</span></h3><p><strong>tip：<strong>若区间为</strong>环</strong>，可将环展开为链，并将链长扩展一倍</p>
<br>

<h3><span id="树形dp">树形dp</span></h3><blockquote>
<p>找树的直径（边权均为正）</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 任取一点做为起点，找到距离该点最远的一个点u</span><br><span class="line">(可证明该点一定是某条直径的端点)</span><br><span class="line">2. 再找到距离u的最远的一点</span><br></pre></td></tr></table></figure>

<p><strong>若包含负权边</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应该枚举全部路径，找出最大长度</span></span><br><span class="line"><span class="comment">//  将所有路径按点分类(点可视为根，因为图为无向图，所以每个点都可作为根)</span></span><br><span class="line"><span class="comment">//  那么枚举所有点，对于每个点再枚举以其为根的树的直径即可</span></span><br><span class="line">dfs(<span class="type">int</span> node, <span class="type">int</span> fa)&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//表示向下走的最长距离</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0</span>, d2 = <span class="number">0</span>    <span class="comment">//最大值和次大值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="comment">/*遍历node的每一个相邻节点 snode*/</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(snode == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> dfs(snode, node) + <span class="comment">/*node -&gt; snode 的距离*/</span></span><br><span class="line">    dist = Math.max(dist, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(d &gt;= d1) d2 = d1, d1 = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2) d2 = d;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = Math.max(ans, d1+d2);     <span class="comment">//d1+d2即为以node为根的树的直径</span></span><br><span class="line">  <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>换根dp</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 指定任意一个根节点</span><br><span class="line">2. 一次dfs遍历，统计出当前子树内的节点对当前节点的贡献</span><br><span class="line">3. 一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案</span><br><span class="line">具体题目见&lt;编程题&gt;中的&lt;树的中心&gt;</span><br></pre></td></tr></table></figure>

<br>

<h3><span id="子序列">子序列</span></h3><p>对于任意给定序列，其<strong>最长上升子序列长度</strong>等于使用<strong>非上升子序列</strong>将整个序列覆盖的<strong>最小数量</strong>，因为两者的贪心做法完全相同（Dilworth定理）</p>
<br>

<h3><span id="数位dp">数位dp</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idx 当前判断到哪一位</span></span><br><span class="line"><span class="comment">//mask 标记哪些已经用过</span></span><br><span class="line"><span class="comment">//isLimit 当前位是否受到约束 如果前几位均和n前几位等同则收到约束，否则最大可9</span></span><br><span class="line"><span class="comment">//isJump 是否可以跳过 用于限制首发数字不为0</span></span><br><span class="line"><span class="comment">//函数表示 构造从高到低第 idx 位及其之后数位的合法方案数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isJump)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == s.length) <span class="keyword">return</span> isJump ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//可以记忆化搜索的情况：不受限</span></span><br><span class="line">    <span class="comment">//因为受限和不受限的情况下，dp值不同，但受限情况下dp值唯一</span></span><br><span class="line">    <span class="keyword">if</span>(!isLimit &amp;&amp; <span class="comment">/* !isJump &amp;&amp; */</span>dp[idx][mask] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[idx][mask];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isJump) res = f(idx+<span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> isJump ? <span class="number">1</span> : <span class="number">0</span>, up = isLimit ? 受限值 : <span class="number">9</span>; d &lt;= up; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((mask &gt;&gt; d) &amp; <span class="number">1</span>) == <span class="number">0</span>) </span><br><span class="line">            res += f(idx+<span class="number">1</span>, mask|(<span class="number">1</span> &lt;&lt; d), isLimit &amp;&amp; d == up, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!isLimit <span class="comment">/* &amp;&amp; !isJump */</span>) dp[idx][mask] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//伪代码模板</span><br><span class="line">//可选参数-具体题目具体分析 pre：上一位 lead：前导0是否存在 </span><br><span class="line">//cnt:某些数字出现的次数 sum:搜索到当前某数字之和</span><br><span class="line">int N = 最长位数;</span><br><span class="line">int dp[N][N], a[N];</span><br><span class="line">int dfs(int pos, /*可选参数 int pre, int lead,*/int limit) &#123;</span><br><span class="line">    if (!pos) &#123;</span><br><span class="line">        边界条件(有时直接 return 1)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre];</span><br><span class="line">    int res = 0, up = limit ? a[pos] : 无限制位;</span><br><span class="line">    for (int i = 0; i &lt;= up; i ++) &#123;</span><br><span class="line">        if (不合法条件) continue;</span><br><span class="line">        res += dfs(pos - 1, 未定参数, lead &amp;&amp; !i, limit &amp;&amp; i == up);</span><br><span class="line">    &#125;</span><br><span class="line">    return limit ? res : (lead ? res : dp[pos][sum] = res);</span><br><span class="line">&#125;</span><br><span class="line">int cal(int x) &#123;</span><br><span class="line">    memset(dp, -1, sizeof dp);    </span><br><span class="line">    len = 0;</span><br><span class="line">    while (x) a[++ len] = x % 进制, x /= 进制;</span><br><span class="line">    return dfs(len, 未定参数, 1, 1);</span><br><span class="line">&#125;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：</strong> 数位dp经常用于<strong>状态压缩</strong>，此时不再是线性dp，很难用for循环遍历（动态规划本质上是求解的一种<strong>拓扑序</strong>），因此就用到<strong>记忆化搜索</strong>(e.g. LCP69)</p>
<h2><span id="树">树</span></h2><h3><span id="morris遍历">Morris遍历</span></h3><p>在迭代版的前、中、后序遍历中，弹栈的目的就是找到当前节点的“后续”节点。而Morris算法，就是在遍历的过程中**“线索化”**，从而优化了栈空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Morris中序遍历为例</span></span><br><span class="line"><span class="comment">//线索化：找predecessor --&gt; predecessor.right = root</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 cur 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor.right != <span class="literal">null</span> &amp;&amp; predecessor.right != cur) &#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    predecessor.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    predecessor.right = <span class="literal">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="字典树-trie">字典树 Trie</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="comment">//还可以添加word字段 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免查找和查头的代码重复</span></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：<strong>主要用于</strong>处理前缀</strong>以及词频统计</p>
<p><strong>易错：</strong> 存在word字段 并在insert()中要修改它时，切记修改的是当前节点的word字段，写法应该是<code>node.word = ...</code> ，容易错写为<code>word = ...</code></p>
<br>

<h2><span id="图论">图论</span></h2><h3><span id="邻接表存储三数组">邻接表存储(三数组)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdjacencyList</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] e, next, head;</span><br><span class="line">    <span class="type">boolean</span>[] v;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, n;            <span class="comment">//仅代表当前数组存放的下标，与node值无关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//n个节点 ：1-n</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdjacencyList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> n+<span class="number">5</span>;</span><br><span class="line">        e = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N];      <span class="comment">//e[idx]=node</span></span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N];    <span class="comment">//next[idx] = idx2</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">int</span>[N];    <span class="comment">//head[node] = idx</span></span><br><span class="line">        v = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边 n1-&gt;n2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        e[idx] = n2;</span><br><span class="line">        next[idx] = head[n1];       <span class="comment">//向头添加</span></span><br><span class="line">        head[n1] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">        v[node] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[node]; i != -<span class="number">1</span>; i = next[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node2</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[node2])&#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="拓扑序">拓扑序</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接上</span></span><br><span class="line"><span class="comment">//q[] 模拟队列  d[node]代表节点入度</span></span><br><span class="line"><span class="comment">//判断是否有拓扑序  执行完q中序列即为拓扑序(如果有的话)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">topoSort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>;        <span class="comment">//队头队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[n] == <span class="number">0</span>) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head[t]; i != -<span class="number">1</span>; i = next[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> e[i];</span><br><span class="line">            d[node]--;</span><br><span class="line">            <span class="keyword">if</span>(d[node] == <span class="number">0</span>) q[++tt] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tt == n-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="最短路问题">最短路问题</span></h3><p><img src="/Blog/img/1e1e6cd6cf3298e009c6e8fb2fbc7ab7.jpg" alt="IMG_20230327_201754.jpg"></p>
<h3><span id="dijkstra">Dijkstra</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于稠密图</span></span><br><span class="line"><span class="type">int</span>[][] g;  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span>[] dist;  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = Math.min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总得来看，寻找最小点需要</strong>$O(n^2)$，<strong>更新节点距离需要</strong>$O(m)$，因此在面对<strong>稀疏图</strong>时，我们可以使用优先队列提高寻找最小点的速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, idx;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span>[] h, w, e, ne;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span>[] dist;        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] t = heap.poll();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ver</span> <span class="operator">=</span> t[<span class="number">1</span>], distance = t[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ver == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[ver]; i != -<span class="number">1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="bellman-ford">Bellman-ford</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于不需要用不到边与边的关系，因此可以直接用一个多维数组或者类来存储</span></span><br><span class="line"><span class="comment">//这里仍然用邻接表存储</span></span><br><span class="line"><span class="type">int</span>[] e, ne, h, w, dist;</span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, n, m, k;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Bellmanford</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//遍历k次 每遍历一次延申一次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">      <span class="comment">//防止串联现象(一次遍历中延申了多次)</span></span><br><span class="line">      <span class="type">int</span>[] dist2 = Arrays.copyOf(dist, n+<span class="number">5</span>);</span><br><span class="line">      <span class="comment">//每次都遍历一遍所有边</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>; n1 &lt;= n; n1++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h[n1]; j != -<span class="number">1</span>; j = ne[j])&#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> e[j], del = w[j];</span><br><span class="line">              <span class="keyword">if</span>(dist[n2] &gt; dist2[n1]+del)&#123;</span><br><span class="line">                  dist[n2] = dist2[n1]+del;</span><br><span class="line">              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//因为有负权边，所以不能通过返回-1来判断找到与否</span></span><br><span class="line">  <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="spfa">SPFA</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于Bellman-Ford,我们想到每次不需要遍历所有的边</span></span><br><span class="line"><span class="comment">//使用队列，遍历那些刚更新过值的边的后继，这便是宽搜优化</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">spfa</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        st[v] = <span class="literal">false</span>;      <span class="comment">//表示当前点是否在队列中，Dijkstra中代表是否在最短集中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[v]; i != -<span class="number">1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[v] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[v] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.offer(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(dist[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过SPFA判断负环：</strong> 另开辟数组<code>cnt</code>，记录从源点到达当前点所经过的<strong>路径数</strong>，当且只当<code>dist</code>更新时才更新<code>cnt</code>。因此如果出现<code>cnt</code>中某个值大于<strong>总点数</strong>，根据容斥原理，必然存在负环。</p>
<h3><span id="floyd">Floyd</span></h3><p><strong>思想：</strong> 基于动态规划，<code>d[k][i][j]</code>表示在只经过前<code>k</code>个节点所构成的路径的前提下，从节点<code>i</code>到节点<code>j</code>的最短距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化最高维</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &gt; d[i][k]+d[k][j]) d[i][j] = d[i][k]+d[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="最小生成树">最小生成树</span></h3><p><img src="/Blog/img/8f20a5322f5e22b82669ec3724f5d27d.jpg" alt="529c3138e9bb91b0fc0f9e74856df0a.jpg"></p>
<h3><span id="prim">Prim</span></h3><p><strong>思想：</strong> 同<em>dijkstra</em>，每次遍历都是找一个距离最近的点加入集合，但是这里的距离最近是指点距离整个集合的距离最近，因此更新<code>dist[]</code>时需要注意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] g;      <span class="comment">//距离矩阵</span></span><br><span class="line"><span class="type">int</span>[] dist;     <span class="comment">//每个点与集合的距离</span></span><br><span class="line"><span class="type">boolean</span>[] st;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span><span class="params">()</span>&#123;</span><br><span class="line">    Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//添加n次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minv</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (minv == -<span class="number">1</span> || dist[j] &lt; dist[minv])) minv = j;</span><br><span class="line">        &#125;</span><br><span class="line">        st[minv] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//找不到合适的点，无法构造</span></span><br><span class="line">        <span class="keyword">if</span>(dist[minv] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dist[minv];</span><br><span class="line">        <span class="comment">//最后更新距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) dist[j] = Math.min(dist[j], g[minv][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="kruskal">Kruskal</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//[a-&gt;b, w]</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//按权值从小到大排序</span></span><br><span class="line">    Collections.sort(lists, (a, b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要考虑两个点是否在同一个连通块中</span></span><br><span class="line">    <span class="type">UnionFind</span> <span class="variable">uset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] e = lists.get(i);</span><br><span class="line">        <span class="keyword">if</span>(uset.unite(e[<span class="number">0</span>], e[<span class="number">1</span>]))&#123;</span><br><span class="line">            res += e[<span class="number">2</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n-<span class="number">1</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="匈牙利算法求二分图最大匹配">匈牙利算法（求二分图最大匹配）</span></h3><p><strong>二分图当且仅当图中不含奇数环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] e, ne, h, matches;    <span class="comment">//n2集合中元素匹配到哪个n1集合中的元素</span></span><br><span class="line"><span class="type">int</span> idx, n1;</span><br><span class="line">Kattio kio;</span><br><span class="line"><span class="type">boolean</span>[] st;   <span class="comment">//对于当前n1集合中这个元素，相应n2集合中某个元素是否被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hungarian</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[u]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[v])&#123;</span><br><span class="line">            st[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matches[v] == <span class="number">0</span> || find(matches[v]))&#123;</span><br><span class="line">                matches[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="启发式搜索a">启发式搜索：A*</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以网格寻路为例 start-&gt;goal</span></span><br><span class="line">frontier = PriorityQueue()  </span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()  <span class="comment">#记录相邻节点的到达关系</span></span><br><span class="line">cost_so_far = <span class="built_in">dict</span>()  <span class="comment">#当前路径代价</span></span><br><span class="line">came_from[start] = <span class="literal">None</span> </span><br><span class="line">cost_so_far[start] = <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> current == goal:  <span class="comment">#精妙的一步</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">#遍历所有邻居(下一种情况)</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      new_cost = cost_so_far[current] + graph.cost(current, <span class="built_in">next</span>)</span><br><span class="line">      <span class="comment">#比较的是当前代价，而不是总代价！！！</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far[<span class="built_in">next</span>]:</span><br><span class="line">         cost_so_far[<span class="built_in">next</span>] = new_cost</span><br><span class="line">         <span class="comment">#总代价：当前代价+预估代价</span></span><br><span class="line">         priority = new_cost + heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算预估代价        </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heuristic</span>(<span class="params">a, b</span>):</span><br><span class="line">   <span class="comment"># Manhattan distance on a square grid</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y)</span><br><span class="line">   <span class="comment"># Chebyshev Distance</span></span><br><span class="line">   <span class="comment"># return Math.max(b.x, b.y)</span></span><br><span class="line">   <span class="comment"># Euclidean Distance</span></span><br><span class="line">   <span class="comment"># return Math.sqrt(Math.pow(a.x-b.x, 2)+Math.pow(a.y-b.y, 2))</span></span><br></pre></td></tr></table></figure>

<p><strong>感悟：</strong> <em>Dijkstra</em> + <em>Greedy Best First Search</em></p>
<p><strong>A star</strong>算法优点在于对环境反应迅速，搜索路径直接，是一种直接的搜索算法，因此被广泛应用于路径规划问题。其缺点是实时性差，每一节点计算量大、运算时间长，而且随着节点数的增多，算法搜索效率降低，<strong>而且A star算法并没有完全遍历所有可行解，所得到的结果不一定是最优解。</strong></p>
<p><strong>选对估值函数很重要，一般用切比雪夫距离</strong></p>
<br>

<h2><span id="位运算">位运算</span></h2><h3><span id="gospers-hack">Gosper’s Hack</span></h3><p>用处：生成 $n$ 元集合中的所有 $k$ 元子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** e.g. GospersHack(2, 4) 依次生成：</span></span><br><span class="line"><span class="comment"> *  0011 0101 0110</span></span><br><span class="line"><span class="comment"> *  1001 1010 1100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GospersHack</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; limit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> cur &amp; -cur;  <span class="comment">//lowbit</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> cur + lb;   <span class="comment">//左半部分</span></span><br><span class="line">        cur = (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lb) | r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3><span id="数组元素位运算">数组元素位运算</span></h3><p>该模板可以做到：</p>
<ol>
<li>求出<strong>所有子数组</strong>的按位或的结果，以及值等于该结果的子数组的个数。</li>
<li>求按位或结果等于<strong>任意给定</strong>数字的子数组的 最短长度&#x2F;最长长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode 2411</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestSubarrays(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">var</span> <span class="variable">ors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;(); <span class="comment">// 按位或的值 + 对应子数组的右端点的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ors.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            <span class="type">var</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> or : ors) &#123;</span><br><span class="line">                or[<span class="number">0</span>] |= nums[i];</span><br><span class="line">                <span class="keyword">if</span> (ors.get(k)[<span class="number">0</span>] == or[<span class="number">0</span>])</span><br><span class="line">                    ors.get(k)[<span class="number">1</span>] = or[<span class="number">1</span>]; <span class="comment">// 合并相同值，下标取最小的</span></span><br><span class="line">                <span class="keyword">else</span> ors.set(++k, or);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为是原地去重，所以要删除冗余的元素</span></span><br><span class="line">            <span class="comment">//也可以 ors.subList(0, k+1)，但耗时</span></span><br><span class="line">            </span><br><span class="line">            ors.subList(k + <span class="number">1</span>, ors.size()).clear();</span><br><span class="line">            <span class="comment">// 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找</span></span><br><span class="line">            ans[i] = ors.get(<span class="number">0</span>)[<span class="number">1</span>] - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2><span id="rmq区间最值">RMQ（区间最值）</span></h2><h3><span id="st表">ST表</span></h3><blockquote>
<p>ST 表是用于解决 可重复贡献问题 的数据结构。</p>
</blockquote>
<p><strong>算法思想：</strong> 基于倍增的思想，令<code>f[i][j]</code>代表区间$[i, i+2^j-1]$的最大值，转移方程也容写出：<code>f[i][j] = max(f[i][j-1], f[i+2^(j-1)][j-1])</code></p>
<p>对于每个询问<code>[l, r]</code>,因为问题<strong>可重复贡献</strong>，我们将其分为两部分求最大值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log函数预处理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pre</span><span class="params">()</span>&#123;</span><br><span class="line">        log2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">            log2[i] = log2[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)-<span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">            f[i][j] = op(f[i][j-<span class="number">1</span>], f[i+(<span class="number">1</span>&lt;&lt;(j-<span class="number">1</span>))][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">  <span class="comment">//核心代码</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">del</span> <span class="operator">=</span> log2[r-l+<span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> op(f[l][del], f[r-(<span class="number">1</span>&lt;&lt;del)+<span class="number">1</span>][del]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2><span id="排序">排序</span></h2><h3><span id="快速排序">快速排序</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int q[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l &gt;= r) return;</span><br><span class="line">    //处理当前区间</span><br><span class="line">    int i = l - 1, j = r + 1, x = q[l+r+1 &gt;&gt; 1];    //注意是向上取整,因为向下取整可能使得x取到q[l]</span><br><span class="line">    while(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++; while(q[i] &lt; x);</span><br><span class="line">        do j--; while(q[j] &gt; x);</span><br><span class="line">        if(i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    //子区间分治</span><br><span class="line">    quick_sort(q, l, i - 1), quick_sort(q, i, r); //必须是 l~i-1 i~r，保证一个&lt;=x、一个&gt;=x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>感悟：</strong> 边界问题太复杂，用时直接敲模板；<strong>快排本质</strong>就是分治，每一步分治的<strong>关键</strong>在于如何将所分区间<strong>分成两份</strong>，若划分标准是<code>x</code>，那么我们目标是将区间分为<code>&gt;= x</code>和<code>&lt;= x</code>两个部分。</p>
<p>首先说明两个游标<code>i、j</code>的含义：当循环结束时，<code>i</code>前面的<code>&lt;= x</code>（不是<code>&lt; x</code>），而包括<code>i</code>及其后面的<code>&gt;= x</code>；<code>j</code>同理。这也就解释了在子区间分治时的传参原因了。</p>
<p>再说<strong>边界问题</strong>：分治最怕<strong>无限分治</strong>，即将<code>n</code>分成<code>0</code>和<code>n</code>。所以当我们进行子区间分治时，若用<code>i</code>划分，则<code>x</code>不能选区间左值；若用<code>j</code>划分，则<code>x</code>不能选区间右值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g. 用 i 划分，选择区间左值作为 x，试试这个例子: [1 2]</span><br></pre></td></tr></table></figure>

<p>实际上，当待排序数组长度为2时才会出现无限递归，完全可以<strong>在数组长度小于某个阈值时，使用插入排序</strong>，以此来规避无限递归。</p>
</div><script type="text/javascript" src="/Blog/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://luozero-world.github.io/Blog/2025/02/23/suan-fa-mo-ban/" data-id="cmbglq6j4000v48l7d1d21swm" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtklEQVR42u3a0Y7aQAwFUP7/p1upTyu1wPX1zC6VTp4QhGTOIMXG9uMRH7/+HF9ff30nef/11ZJP/z7z2IGHh4dXLf3Z8XoRz0ivr5xsWX7+m5Xg4eHhXeMlweB1GEgCQ3KvZBMH18HDw8P7UV4SBpKkvAPg4eHh/Y+8hLpJtZOkGQ8PD+9zeN3NEmqSiCdp+vVaCx4eHl7M6xpgP/v6en8PDw8Pr+qqdwGg++40qER3wcPDw7vAe32D6QBW90DvRrIGAQMPDw/vAm/z5a58kLfBuvbb0zXj4eHhHeLtE99NUr4pAUe/Gx4eHt5RXldcODVwsAknUdMLDw8P7wJvWp6YBoZuifmGlqMDeHh4eId4XfmgK2Tk2zf9bjRZhoeHh7fmdQvdpNf5fNS0Xff0d8PDw8M7yssDQ5L+TpfYNcmmpV48PDy8U7y83ZWnv5v387GtA1VqPDw8vKO8bgumKW83RDUIXXh4eHgXeNOyQnLpbpxrmmqP/yvg4eHhXeblAwF5QXZ6tS7A4OHh4d3m7QsK04LFlDpN+v/xjwEPDw/vKC+JG10xd3pOnlKPS8x4eHh4R3lRG6l6WG8aV93owJtpCDw8PLxDvOlj+sZIwTQkPE4deHh4eBUvX2i36E0jbdoqG3f28PDw8Cped/tpCWMzWJAXI8oBVjw8PLxDvK71tQfnRYeuOIKHh4d3ipc8+nPY9IGew6bn4OHh4X0/rwseeZtqGki6YgceHh7eWV43lJ8/sqcBJi+LRAk3Hh4e3gXepgufDz8lSfCpALOaksDDw8Or6px54WC6BafOz4cP8PDw8G7zkttvQkieoHfFETw8PLxP5u1f55i8wIGHh4f3mbxTo6tJ2SL/9E0IwcPDw7vGmw7TT5PmTfLdFUfw8PDw7vHuNcDyNn83jNVtKx4eHt6C9xuKskrfLS677QAAAABJRU5ErkJggg==">分享</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Blog/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul></div><div class="post-nav"><a class="pre" href="/Blog/2025/05/15/fen-bu-shi-suo-zhu-dong-lun-xun-xing-vs-jian-ting-xing/">分布式锁：主动轮询型vs监听回调型</a><a class="next" href="/Blog/2025/01/12/hu-lun-tun-zao-yu-hou-ji/">囫囵吞枣与2024后记</a></div><div class="nofancybox" id="waline"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/@waline/client@v3/dist/waline.css"><script type="module">import {init} from 'https://unpkg.com/@waline/client@v3/dist/waline.js';
init({
  el: '#waline',
  comment: true,
  serverURL: 'waline-sigma.vercel.app',
  pageSize: '10',
  wordLimit: '500',
  requiredMeta,
  emoji: [
    '//unpkg.com/@waline/emojis@1.2.0/weibo',
    '//unpkg.com/@waline/emojis@1.2.0/qq',
    '//unpkg.com/@waline/emojis@1.2.0/tw-emoji',
  ],
});</script><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
</script></div><aside class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Manachar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">二维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">离散化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">埃氏筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">线性筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">求组合数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">数字三角形dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">状压dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">区间dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">树形dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">数位dp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Morris遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">字典树 Trie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">邻接表存储(三数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">拓扑序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">最短路问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Bellman-ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">SPFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Floyd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">匈牙利算法（求二分图最大匹配）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">启发式搜索：A*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Gosper’s Hack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">数组元素位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">RMQ（区间最值）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">ST表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">快速排序</span></a></li></ol></li></ol></aside></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/Blog/img/myphoto.jpg"/></a><p>Premature optimization is the root of all evil.</p><a class="info-icon" href="mailto:13097638440@163.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/LuoZero-World" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://space.bilibili.com/649588534" title="Bilibili" target="_blank" style="margin-inline:5px"> <i class="fa fa-reddit-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">项目总结</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/Blog/tags/2023/" style="font-size: 15px;">2023</a> <a href="/Blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/Blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/Blog/tags/JUC/" style="font-size: 15px;">JUC</a> <a href="/Blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">基础知识</a> <a href="/Blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/Blog/tags/2024/" style="font-size: 15px;">2024</a> <a href="/Blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/Blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 15px;">动态规划</a> <a href="/Blog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 15px;">图论</a> <a href="/Blog/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">推荐系统</a> <a href="/Blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/Blog/tags/Nginx/" style="font-size: 15px;">Nginx</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Blog/2025/05/15/fen-bu-shi-suo-zhu-dong-lun-xun-xing-vs-jian-ting-xing/">分布式锁：主动轮询型vs监听回调型</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2025/02/23/suan-fa-mo-ban/">算法模板</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2025/01/12/hu-lun-tun-zao-yu-hou-ji/">囫囵吞枣与2024后记</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2024/06/12/yin-le-tui-jian-xi-tong/">音乐推荐系统</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2024/05/23/java-duo-xian-cheng-she-ji-mo-shi/">Java多线程设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/12/28/2023-zhe-yi-nian/">2023这一年</a></li><li class="post-list-item"><a class="post-list-link" href="/Blog/2023/10/07/java-he-xin-ji-zhu/">Java核心技术I (Version.12)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://chuixue-lan.github.io/Blog/" title="吹雪の博客" target="_blank">吹雪の博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/Blog/." rel="nofollow">LuoZero's World.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/Blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/Blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/Blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/Blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/Blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/Blog/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/Blog/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/Blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/Blog/js/smartresize.js?v=1.0.0"></script></div></body></html>